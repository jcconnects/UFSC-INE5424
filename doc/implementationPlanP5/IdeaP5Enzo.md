# Idea 1 for P5

## First off, we have to create a virtual collision domain

- This will be done by sending in the FRAME the coordinates of origin and the radius of the circle that will represent our collision domain.
- Whenever a NIC receives a message, it will check if the distance from the origin to the NIC's coordinates is higher than the radius, if so discarding the message.
- To implement this, we will create a GPS Singleton class, similar to our Clock, that will have a get(timestamp)-> (lat, lon) method, that simply returns the coordinates of the NIC given the timestamp.
- - For P5 this get method will read from a csv file that contains the coordinates of the NICs at different timestamps (trajectory file). This file can be generated by a python script that receives the lifetime of the vehicle and creates a trajectory, for instance. When get is called, it will check the first timestamp that is higher than the one given, and return the coordinates of the NIC at that timestamp.
- - For P7 this get method will simply access the IoT platform from LISHA, or acess the same file as before but filled by the platform.
- - Every application can easily use the GPS coordinates if it was because it is a Singleton class. (but we could make some kind of interface to facilitate the usage by applications)

## Secondly, we make the RSUs generate STATUS messages instead of RESPONSE messages (which they are currently generating in P4)

- The STATUS messages will contain the session Key from the RSU

## Now the vehicles need to be able to handle STATUS messages

- They will have a StatusManager Singleton class, used by the Protocol in the UPDATE!!!
- The Protocol on reception of a STATUS message will simply send the origin, key and maybe distance somehow to the StatusManager, which will store these fields in a dictionary with the origin as key and the key and distance as values, ordered by the distance.
- We have to think how can we make the Protocol understand that the message is a STATUS message, maybe adding a bit to the frame?

## Now we need to make the vehicles send INTEREST and RESPONSE messages that are authenticated with the MAC using the session key

- When sending an INTEREST/RESPONSE message, the Protocol will check if the StatusManager has elements in the dictionary, if so it will get the closest RSU and use its session key to calculate the MAC of the message 
- We need to think where the MAC is going to be, maybe in the frame header?
- The StatusManager check for timeout of the RSUs, in each activation (think this better), to remove the RSUs that are not in the range anymore.
- STATUS messages should not be authenticated (by the RSUs) and all other messages should be authenticated, how to do this separation?
- Upon reception, the Protocol will check if the message is authenticated to ANY of the RSUs in the StatusManager, if so it will process the message, if not it will (*)

## (*) Handling the problem of no-intersection between the collision domains of the RSUs

- In the RARE case where telecom chooses to not have redundancy in the RSUs, we will have to handle the case where the RSUs' collision domains do not intersect. It raises a problem because vehicles in the border of R1 will not be able to receive messages from vehicles in the border of R2, for instance.
- To handle this, one approach proposed here is (*):
- - The moment a vehicle V1 receives a message from V2, and the Protocol identifies that the message is not authenticated by any RSU in the StatusManager, it will send a REQUEST message to the closest RSU (unicast) asking for the session key of the RSU that has V2 in its group.
- - The RSU will receive this REQUEST, which also contains the coordinates of V1, and *TALK* to the other RSUs that are closer to V1 to identify if V2 is in its group (for security reasons!). If so, it will send an extra REQUESTRESPONSE message TO V1 (unicast) containing the session key of the RSU that has V2 in its group.
- - V1 will receive this REQUESTRESPONSE and process it exactly as it would process a STATUS message, adding the RSU to the StatusManager. But it will also send a REQUESTRESPONSEACK to the RSU that sent the REQUESTRESPONSE to acknowledge the reception.
- - If the RSU does not receive the REQUESTRESPONSEACK it will resend the REQUESTRESPONSE message to V1 upon a timeout and will try to resend it a few times, until it gives up.
- RSUs will always receive messages sent from vehicles in their group because they are in the collision domain and are authenticated by the session key, and they will always keep track of the vehicles in their group, removing them after a timeout.
- This approach is good, because if the telecom companies place the RSUs with redundancy and intersections, there will be no need for this protocoled communication regarding REQUEST and REQUESTRESPONSE messages, which will save bandwidth and processing time, automatically and dynamically making the system more efficient.

## We only need to improve the implementation details of the above steps!