@startuml 01-system_sequence_socket_engine_communication_diagram

' Process flow
participant "Component <<Component>>" as Component
participant "Main Thread" as MainThread
participant "Dispatcher Thread" as DispatcherThread
participant "Vehicle <<Process>>" as Vehicle
participant "Message" as Message
participant "Communicator <<Concurrent_Observer>>" as Communicator
participant "Protocol <<Conditional_Data_Observer>>" as Protocol
participant "NIC" as NIC
participant "SocketEngine <<External_Engine>>" as SocketEngine
participant "NIC <<Physical>>" as NIC_Physical

autonumber
-> Component: start()
create MainThread
Component -> MainThread: pthread_create(thread_entry_point, this)
note right of MainThread: Executes component's run() method
create DispatcherThread
Component -> DispatcherThread: pthread_create(component_dispatcher_launcher, this)
note right of DispatcherThread: Handles message dispatching
MainThread -> MainThread: run()
note right of MainThread: Main loop, specific for each component

loop while (_dispatcher_running)
    alt _communicator->receive(&message)
        note right of DispatcherThread: Received message
        alt msg_type == Message::Type::INTEREST && _produced_data_type != DataTypeId::UNKNOWN
            note right of DispatcherThread: Received INTEREST message
            alt data_type == _produced_data_type
                note right of DispatcherThread: Received INTEREST for produced data type
                DispatcherThread -> DispatcherThread: store_interest_period(period)
                note right of DispatcherThread: Stores new period and updates GCD if needed
                alt !_producer_thread_running.load(std::memory_order_acquire)
                    note right of DispatcherThread: Starts producer response thread if it's not already running
                    DispatcherThread -> DispatcherThread: start_producer_response_thread()
                end
            end
        else msg_type == Message::Type::RESPONSE
            DispatcherThread -> DispatcherThread: "handle response"
        end
    else
        DispatcherThread -> DispatcherThread: "usleep(1000)"
    end
end

Vehicle -> Message: Create
Message -> Vehicle: Message
Vehicle -> Communicator: send(Message)
Communicator -> Protocol: send(address, BROADCAST, data, size)
activate Protocol
Protocol -> NIC: alloc(address, PROTO, size)
NIC --> Protocol: return buffer
note right of Protocol: Copy data to buffer
Protocol -> NIC: send(buf)
note right of NIC: Get destination MAC address from buffer
alt dest_mac == my_mac 
    note right of NIC: Send to internal engine
else
    NIC -> SocketEngine: send(buf->data(), buf->size())
    SocketEngine --> NIC_Physical: sendto(Frame, size)
end
deactivate Protocol

==== Network Layer Boundary ====

' NIC receives data from the network
NIC_Physical <-: F 
NIC_Physical -> SocketEngine: handleSignal()
SocketEngine -> NIC: receiveData(PROTO, buffer)
activate NIC
NIC -> NIC: notify(PROTO, buffer)
NIC -> Protocol: update(PROTO, buffer)
activate Protocol
Protocol -> Protocol: notify(dst_port, buffer)
note right of Protocol: Extract dst_port from packet
Protocol -> Communicator: update(condition, data)
note right of Communicator: Calls update and releases the thread waiting for data
deactivate Protocol
deactivate NIC

Vehicle -> Communicator: receive(Message)
activate Communicator
Communicator -> Communicator: updated()
note right of Communicator: Method inherited from Observer pattern class that waits until data is returned
deactivate Communicator
note right of Vehicle: Updated that data is available

@enduml 