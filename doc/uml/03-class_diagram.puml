@startuml 03-class_diagram

skinparam classBackgroundColor<<Component>> #fcd5d5
skinparam classBackgroundColor<<Communication>> #E0FFFF
skinparam classBackgroundColor<<Core>> #FFEBCD
skinparam classBackgroundColor<<Observer>> #E6E6FA
skinparam classBackgroundColor<<Engine>> #F0FFF0

class Buffer<T> <<Communication>> {
  - _data: std::uint8_t[MAX_SIZE]
  - _size: unsigned int
  + {static} constexpr MAX_SIZE: unsigned int = sizeof(T)
  + Buffer()
  - setSize(size: unsigned int): void
  + ~Buffer()
  + data(): T*
  + setData(data: const void*, size: unsigned int): void
  + size(): const unsigned int const
  + clear(): void
}

class Communicator<Channel> <<Communication>> {
  + {static} constexpr MAX_MESSAGE_SIZE: unsigned int
  + {static} constexpr GATEWAY_PORT: Port
  + {static} constexpr INTERNAL_BROADCAST_PORT: Port
  + {static} constexpr MIN_COMPONENT_PORT: Port
  - _channel: Channel*
  - _address: Address
  - _closed: std::atomic<bool>
  - _owner_type: ComponentType
  - _owner_data_type: DataTypeId
  - _interested_data_type: DataTypeId
  - _interested_period_us: std::uint32_t
  - _last_accepted_response_time_us: std::uint64_t
  - _interest_period_callback: InterestPeriodCallback
  + Communicator(channel: Channel*, address: Address, owner_type: ComponentType = ComponentType::UNKNOWN, owner_data_type: DataTypeId = DataTypeId::UNKNOWN)
  + ~Communicator()
  + new_message(message_type: Message::Type, unit_type: DataTypeId, period: unsigned int = 0, value_data: const void* = nullptr, value_size: const unsigned int = 0): Message
  + send(message: const Message&, destination: const Address& = Channel::Address::BROADCAST): bool
  + receive(message: Message*): bool
  + close(): void
  + is_closed(): const bool
  + address(): const Address& const
  + set_interest(type: DataTypeId, period_us: std::uint32_t = 0): bool
  + get_interest_type(): DataTypeId const
  + get_interest_period(): std::uint32_t const
  + set_interest_period_callback(callback: InterestPeriodCallback): void
  - update(c: Channel::Observer::Observing_Condition, buf: Channel::Observer::Observed_Data*): void
  .. Typedefs ..
  + Observer: typedef
  + Buffer: typedef
  + Address: typedef
  + Port: typedef
  + InterestPeriodCallback: typedef std::function<void(std::uint32_t)>
  .. Deleted methods ..
  + Communicator(const Communicator&) = delete
  + operator=(const Communicator&) = delete
}

note top of Communicator
  Inherits from Concurrent_Observer<
    typename Channel::Observer::Observed_Data,
    typename Channel::Observer::Observing_Condition>
end note

class Ethernet <<Communication>> {
  + {static} constexpr MTU: unsigned int = 1500
  + {static} constexpr MAC_SIZE: unsigned int = 6
  + {static} constexpr HEADER_SIZE: unsigned int
  + {static} NULL_ADDRESS: Address
  + {static} BROADCAST: Address
  + Ethernet() = default
  + ~Ethernet() = default
  + {static} mac_to_string(addr: Address): std::string
  .. Nested types ..
  + Address: struct
  + Protocol: typedef unsigned int
  + Frame: struct
}

class "Ethernet::Address" as EthernetAddress <<struct>> <<Communication>> {
  + bytes: std::uint8_t[MAC_SIZE]
}

note top of EthernetAddress
  + operator==(other: const Address&): bool
  + operator!=(other: const Address&): bool
  defined as global inline functions
end note

class "Ethernet::Frame" as EthernetFrame <<struct>> <<Communication>> {
  + dst: Address
  + src: Address
  + prot: Protocol
  + payload: std::uint8_t[MTU - HEADER_SIZE]
}

class Initializer <<Core>> {
  + Initializer() = default
  + ~Initializer() = default
  + {static} create_nic(): NIC_T*
  + {static} create_protocol(nic: NIC_T*): PROTOCOL_T*
  .. Typedefs ..
  + NIC_T: typedef NIC<SocketEngine, SharedMemoryEngine>
  + PROTOCOL_T: typedef Protocol<NIC_T>
}

class Message <<Communication>> {
  - _message_type: Type
  - _origin: Origin
  - _timestamp: std::uint64_t
  - _unit_type: DataTypeId
  - _period: std::uint32_t
  - _value: std::vector<std::uint8_t>
  - _serialized_data: std::vector<std::uint8_t>
  + Message(message_type: Type, origin: const Origin&, unit_type: DataTypeId, period: unsigned int = 0, value_data: const void* = nullptr, value_size: const unsigned int = 0)
  + ~Message() = default
  + message_type(): const Type&
  + origin(): const Origin&
  + timestamp(): const std::uint64_t&
  + unit_type(): const DataTypeId&
  + period(): const unsigned int
  + value(): const std::uint8_t*
  + value_size(): const unsigned int
  + data(): const void*
  + size(): const unsigned int
  + {static} deserialize(serialized: const void*, size: const unsigned int): Message
  - Message() = default
  - message_type(message_type: const Type): void
  - origin(addr: const Origin&): void
  - timestamp(timestamp: const std::uint64_t&): void
  - unit_type(type: DataTypeId): void
  - period(period: const std::uint32_t&): void
  - value(data: const void*, size: const unsigned int): void
  - serialize(): void
  - append_address(origin: const Origin&): void
  - append_uint8t(value: const std::uint8_t&): void
  - append_uint32t(value: const std::uint32_t&): void
  - append_uint64t(value: const std::uint64_t&): void
  - append_vector(v: const std::vector<std::uint8_t>&): void
  - {static} extract_address(data: const std::uint8_t*, offset: unsigned int&, max_size: unsigned int): Origin
  - {static} extract_uint8t(data: const std::uint8_t*, offset: unsigned int&, max_size: unsigned int): std::uint8_t
  - {static} extract_uint32t(data: const std::uint8_t*, offset: unsigned int&, max_size: unsigned int): std::uint32_t
  - {static} extract_uint64t(data: const std::uint8_t*, offset: unsigned int&, max_size: unsigned int): std::uint64_t
  .. Typedefs and enums ..
  + Type: enum class
  + Origin: typedef Protocol<NIC<SocketEngine, SharedMemoryEngine>>::Address
}



note bottom of Message
  TheMessage = Message<Constants::MAX_MESSAGE_SIZE>
end note

class "NIC<ExternalEngine, InternalEngine>" as NIC <<Communication>> {
  + {static} const N_BUFFERS: unsigned int
  + {static} constexpr MAX_FRAME_SIZE: unsigned int = sizeof(Ethernet::Frame)
  - _address: Address
  - _statistics: Statistics
  - _buffer: DataBuffer[N_BUFFERS]
  - _buffer_pool: std::queue<DataBuffer*>
  - _running: std::atomic<bool>
  - _binary_sem: sem_t
  - _free_buffer_count: unsigned int
  # NIC()
  + ~NIC()
  + send(buf: DataBuffer*): int
  + receive(buf: DataBuffer*, src: Address*, dst: Address*, data: void*, size: unsigned int): int
  + alloc(dst: Address, prot: Protocol_Number, size: unsigned int): DataBuffer*
  + free(buf: DataBuffer*): void
  + buffer_pool_size(): const unsigned int
  + address(): const Address&
  + setAddress(address: Address): void
  + statistics(): const Statistics&
  + stop(): void
  + running(): const bool
  - handleExternal(frame: Ethernet::Frame*, size: unsigned int): void
  - handleInternal(buf: DataBuffer*): void
  .. Typedefs ..
  + Address: typedef Ethernet::Address
  + Protocol_Number: typedef Ethernet::Protocol
  + DataBuffer: typedef Buffer<Ethernet::Frame>
  + Observer: typedef Conditional_Data_Observer<DataBuffer, Protocol_Number>
  + Observed: typedef Conditionally_Data_Observed<DataBuffer, Protocol_Number>
  .. Nested types ..
  + Statistics: struct 
}

note top of NIC
  Inherits from:
  - Ethernet
  - Conditionally_Data_Observed<Buffer<Ethernet::Frame>, Ethernet::Protocol>
  - private ExternalEngine
  - private InternalEngine
end note

class "NIC<ExternalEngine, InternalEngine>::Statistics" as NICStatistics <<struct>> <<Communication>> {
  + packets_sent: std::atomic<unsigned int>
  + packets_received: std::atomic<unsigned int>
  + bytes_sent: std::atomic<unsigned int>
  + bytes_received: std::atomic<unsigned int>
  + tx_drops: std::atomic<unsigned int>
  + rx_drops: std::atomic<unsigned int>
  + Statistics()
}

class "Conditional_Data_Observer<T, Condition>" as ConditionalDataObserver <<Observer>> {
  # _rank: Condition
  # _data: List<T>
  + {typedef} Observed_Data: T
  + {typedef} Observing_Condition: Condition
  + {typedef} Observed: Conditionally_Data_Observed<T, Condition>
  + Conditional_Data_Observer(c: Condition)
  + {virtual} ~Conditional_Data_Observer() = default
  + {virtual} update(c: Condition, d: Observed_Data*): void
  + {virtual} updated(): T*
  + rank(): const Condition
}

class "Conditionally_Data_Observed<T, Condition>" as ConditionallyDataObserved <<Observer>> {
  # _observers: Observers
  + {typedef} Observed_Data
  + {typedef} Observing_Condition
  + {typedef} Observer
  + {typedef} Observers: Ordered_List<Observer, Condition>
  + Conditionally_Data_Observed() = default
  + {virtual} ~Conditionally_Data_Observed() = default
  + attach(o: Observer*, c: Condition): void
  + detach(o: Observer*, c: Condition): void
  + notify(c: Condition, d: T*): bool
  + notifyAll(d: T*): bool
  + notifyInternalBroadcast(original_buf: T*, broadcast_port: Condition, source_port: Condition, clone_buffer: std::function<T*(T*)>): bool
  + get_observers(): Observers&
}

class "Concurrent_Observer<D, C>" as ConcurrentObserver <<Observer>> {
  - _semaphore: sem_t
  + {typedef} Observed_Data: D
  + {typedef} Observing_Condition: C
  + {typedef} Observed: Concurrent_Observed<D, C>
  + Concurrent_Observer(rank: C)
  + ~Concurrent_Observer()
  + update(c: C, d: D*): void override
  + updated(): D*
}

note bottom of ConcurrentObserver
  Inherits from Conditional_Data_Observer<D, C>
end note

class "Concurrent_Observed<D, C>" as ConcurrentObserved <<Observer>> {
  - _mtx: pthread_mutex_t
  - _observers: Observers
  + {typedef} Observed_Data
  + {typedef} Observing_Condition
  + {typedef} Observers: Ordered_List<Concurrent_Observer<D, C>, C>
  + Concurrent_Observed()
  + ~Concurrent_Observed()
  + attach(o: Concurrent_Observer<D, C>*, c: C): void
  + detach(o: Concurrent_Observer<D, C>*, c: C): void
  + notify(c: C, d: D*): bool
  + notifyInternalBroadcast(original_buf: D*, broadcast_port: C, source_port: C, clone_buffer: std::function<D*(D*)>): bool
}

note bottom of ConcurrentObserved
  Inherits from Conditionally_Data_Observed<D, C>
end note

class "Protocol<NIC>" as ProtocolNIC <<Communication>> {
  + {static} const PROTO: NIC::Protocol_Number
  + {static} const MTU: unsigned int
  + {static inline} const GATEWAY_PORT: Port = 0
  + {static inline} const INTERNAL_BROADCAST_PORT: Port = 1
  + {static inline} const MIN_COMPONENT_PORT: Port = 2
  - _nic: NIC*
  - {static} _observed: Observed
  + Protocol(nic: NIC*)
  + ~Protocol()
  + send(from: Address, to: Address, data: const void*, size: unsigned int): int
  + receive(buf: Buffer*, from: Address*, data: void*, size: unsigned int): int
  + peek(buf: Buffer*, data: void*, size: unsigned int): int
  + free(buf: Buffer*): void
  + {static} attach(obs: Observer*, address: Address): void
  + {static} detach(obs: Observer*, address: Address): void
  - update(prot: NIC::Protocol_Number, buf: Buffer*): void override
  .. Typedefs ..
  + Buffer: typedef
  + Physical_Address: typedef
  + Port: typedef std::uint16_t
  + Observer: typedef
  + Observed: typedef
  + Data: typedef std::uint8_t[MTU]
}

note top of ProtocolNIC
  Inherits from NIC::Observer
end note

class "Protocol<NIC>::Header" as ProtocolHeader <<Communication>> {
  - _from_port: Port
  - _to_port: Port
  - _size: unsigned int
  + Header()
  + from_port(): Port const
  + from_port(p: Port): void
  + to_port(): Port const
  + to_port(p: Port): void
  + size(): unsigned int const
  + size(s: unsigned int): void
}

class "Protocol<NIC>::Packet" as ProtocolPacket <<Communication>> {
  - _data: Data
  + Packet()
  + header(): Header*
  + data<T>(): T*
}

class "Protocol<NIC>::Address" as ProtocolAddress <<Communication>> {
  - _port: Port
  - _paddr: Physical_Address
  + {static} const BROADCAST: Address
  + Address()
  + Address(null: Null)
  + Address(paddr: Physical_Address, port: Port)
  + paddr(addr: Physical_Address): void
  + paddr(): const Physical_Address&
  + port(port: Port): void
  + port(): const Port&
  + to_string(): const std::string
  + operator bool(): bool const
  + operator==(a: const Address&): bool const
  .. Nested types ..
  + Null: enum
}

note top of ProtocolPacket
  Inherits from Protocol<NIC>::Header
end note

class SocketEngine <<Engine>> {
  + {static} INTERFACE(): const char*
  # _sock_fd: int
  # _ep_fd: int
  # _if_index: int
  # _mac_address: Ethernet::Address
  - _stop_ev: const int
  - _receive_thread: pthread_t
  - _running: std::atomic<bool>
  + SocketEngine()
  + {virtual} ~SocketEngine()
  + start(): void
  + stop(): void
  + running(): const bool
  + send(frame: Ethernet::Frame*, size: unsigned int): int
  + {static} run(arg: void*): void*
  + mac_address(): const Ethernet::Address&
  - setUpSocket(): void
  - setUpEpoll(): void
  - receive(): void
  - {virtual} handleExternal(frame: Ethernet::Frame*, size: unsigned int): void = 0
}

class Vehicle <<Core>> {
  - _id: unsigned int
  - _protocol: VehicleProt*
  - _nic: VehicleNIC*
  - _running: std::atomic<bool>
  - _components: std::vector<std::unique_ptr<Component>>
  + Vehicle(id: unsigned int)
  + ~Vehicle()
  + id(): const unsigned int const
  + running(): const bool const
  + start(): void
  + stop(): void
  + create_component<ComponentType, Args...>(name: const std::string&, args: Args&&...): void
  + start_components(): void
  + stop_components(): void
  + start_component(component_name: const std::string&): void
  + get_component(name: const std::string&): Component*
  + protocol(): VehicleProt* const
  + address(): const Address const
  + {static} get_producer_port_map(): std::map<DataTypeId, Ports>
  + get_producer_ports(): std::map<DataTypeId, Ports> const
  + get_all_component_addresses(): std::vector<Address> const
  .. Typedefs ..
  + VehicleNIC: typedef NIC<SocketEngine, SharedMemoryEngine>
  + VehicleProt: typedef Protocol<VehicleNIC>
  + Address: typedef VehicleNIC::Address
  .. Nested types ..
  + Ports: enum class
}

class Component<<Component>> {
  # _vehicle: const Vehicle*
  # _name: std::string
  # _running: std::atomic<bool>
  # _thread: pthread_t
  # _communicator: Comms*
  # _gateway_address: Address
  # _address: Address
  # _filename: std::string
  # _log_dir: std::string
  # _log_file: std::ofstream
  # _produced_data_type: DataTypeId
  # _interest_periods: std::vector<std::uint32_t>
  # _periods_mutex: std::mutex
  # _current_gcd_period_us: std::atomic<std::uint32_t>
  # _producer_thread: pthread_t
  # _producer_thread_running: std::atomic<bool>
  # _has_dl_capability: std::atomic<bool>
  # _interested_data_type: DataTypeId
  # _interested_period_us: std::uint32_t
  # _data_callback: std::function<void(const Message&)>
  - _component_actual_type: ComponentType
  + {static} inline GATEWAY_PORT: unsigned int
  + {static} inline INTERNAL_BROADCAST_PORT: unsigned int
  + {static} inline MIN_COMPONENT_PORT: unsigned int
  + Component(vehicle: Vehicle*, vehicle_id: const unsigned int, name: const std::string&, component_type: ComponentType)
  + {virtual} ~Component() = default
  + start(): void
  + stop(): void
  + {virtual} run(): void = 0
  + running(): const bool const
  + getName(): const std::string&
  + vehicle(): const Vehicle* const
  + log_file(): std::ofstream*
  + address(): const Address& const
  + type(): ComponentType const
  + send(data: const void*, size: unsigned int, destination: Address = Address::BROADCAST): int
  + receive(msg: Message*): int
  + register_interest(type: DataTypeId, period_us: std::uint32_t, callback: std::function<void(const Message&)>): void
  + send_interest_message(): void
  + get_produced_data_type(): DataTypeId const
  + get_interest_type(): DataTypeId const
  + get_interest_period(): std::uint32_t const
  + handle_interest_period(period: std::uint32_t): void
  # thread_entry_point(arg: void*): static void*
  # set_address(addr: const Address&): void
  # open_log_file(): void
  # close_log_file(): void
  # initialize_log_directory(vehicle_id: unsigned int): std::string
  # producer_thread_launcher(context: void*): static void*
  # producer_routine(): void
  # start_producer_thread(): void
  # stop_producer_thread(): void
  # update_gcd_period(): std::uint32_t
  # {static} calculate_gcd(a: std::uint32_t, b: std::uint32_t): std::uint32_t
  # has_deadline_scheduling_capability(): bool
  # {virtual} produce_data_for_response(type: DataTypeId, out_value: std::vector<std::uint8_t>&): bool
  .. Typedefs ..
  + VehicleNIC: typedef NIC<SocketEngine, SharedMemoryEngine>
  + VehicleProt: typedef Protocol<VehicleNIC>
  + Comms: typedef Communicator<VehicleProt>
  + Address: typedef Comms::Address
}

class BatteryComponent<<Component>> {
  - _gen: std::mt19937
  - _voltage_dist: std::uniform_real_distribution<>
  - _current_dist: std::uniform_real_distribution<>
  - _temp_dist: std::uniform_real_distribution<>
  - _soc_dist: std::uniform_real_distribution<>
  - _current_data: BatteryStatusData
  + {static} const PORT: unsigned int
  + BatteryComponent(vehicle: Vehicle*, vehicle_id: const unsigned int, name: const std::string&, protocol: VehicleProt*)
  + ~BatteryComponent() = default
  + run(): void override
  # produce_data_for_response(type: DataTypeId, out_value: std::vector<std::uint8_t>&): bool override
  - update_battery_data(): void
  .. Nested types ..
  + BatteryStatusData: struct
}

class CameraComponent<<Component>> {
  - _rng: std::mt19937
  - _temp_dist: std::uniform_real_distribution<float>
  - _humidity_dist: std::uniform_real_distribution<float>
  - _status_dist: std::uniform_int_distribution<uint8_t>
  - _current_data: TemperatureData
  + {static} const PORT: unsigned int
  + CameraComponent(vehicle: Vehicle*, vehicle_id: const unsigned int, name: const std::string&, protocol: VehicleProt*)
  + ~CameraComponent() = default
  + run(): void override
  # produce_data_for_response(type: DataTypeId, out_value: std::vector<std::uint8_t>&): bool override
  - update_temperature_data(): void
  .. Nested types ..
  + TemperatureData: struct
}

class ECUComponent<<Component>> {
  - _latest_obstacle_data: struct {distance_meters: float, angle_degrees: float, confidence: uint8_t, data_valid: bool, last_update: timepoint, mutex: std::mutex}
  + {static inline} const OBSTACLE_DATA_PERIOD_US: std::uint32_t = 300000
  + ECUComponent(vehicle: Vehicle*, vehicle_id: const unsigned int, name: const std::string&, protocol: VehicleProt*, port: unsigned int)
  + ~ECUComponent() = default
  + run(): void override
  - handle_obstacle_data(message: const Message&): void
  - parse_obstacle_data(message: const Message&, out_data: ObstacleData&): bool
  - log_message(message: const Message&, recv_time: const std::chrono::microseconds&, timestamp: const std::chrono::microseconds&, message_details: const std::string&): void
  .. Nested types ..
  - ObstacleData: struct {distance_meters: float, angle_degrees: float, confidence: uint8_t}
}

class LidarComponent<<Component>> {
  - _rng: std::mt19937
  - _dist_dist: std::uniform_real_distribution<float>
  - _angle_dist: std::uniform_real_distribution<float>
  - _confidence_dist: std::uniform_int_distribution<uint8_t>
  - _current_data: ObstacleDistanceData
  + {static} const PORT: unsigned int = 101
  + LidarComponent(vehicle: Vehicle*, vehicle_id: const unsigned int, name: const std::string&, protocol: VehicleProt*)
  + ~LidarComponent() = default
  + run(): void override
  # produce_data_for_response(type: DataTypeId, out_value: std::vector<std::uint8_t>&): bool override
  - update_obstacle_data(): void
  .. Nested types ..
  + ObstacleDistanceData: struct
}

class INSComponent<<Component>> {
  - _gen: std::mt19937
  - _lat_dist: std::uniform_real_distribution<>
  - _lon_dist: std::uniform_real_distribution<>
  - _alt_dist: std::uniform_real_distribution<>
  - _vel_dist: std::uniform_real_distribution<>
  - _heading_dist: std::uniform_real_distribution<>
  - _current_data: GPSPositionData
  + {static} const PORT: unsigned int = 104
  + INSComponent(vehicle: Vehicle*, vehicle_id: const unsigned int, name: const std::string&, protocol: VehicleProt*)
  + ~INSComponent() = default
  + run(): void override
  # produce_data_for_response(type: DataTypeId, out_value: std::vector<std::uint8_t>&): bool override
  - update_gps_data(): void
  .. Nested types ..
  + GPSPositionData: struct
}

class SharedMemoryEngine <<Engine>> {
  + SharedMemoryEngine()
  + ~SharedMemoryEngine()
  + start(): void
  + stop(): void
  + send(buf: Buffer<Ethernet::Frame>*): int
  - {virtual} handleInternal(buf: Buffer<Ethernet::Frame>*): void = 0
  .. Deleted methods ..
  + SharedMemoryEngine(const SharedMemoryEngine&) = delete
  + operator=(const SharedMemoryEngine&) = delete
}

class BasicConsumer <<Component>> {
  - _latest_test_data: struct
  + {static} const PORT: unsigned int = 106
  + {static inline} const TEST_DATA_PERIOD_US: std::uint32_t = 500000
  + BasicConsumer(vehicle: Vehicle*, vehicle_id: const unsigned int, name: const std::string&, protocol: VehicleProt*)
  + ~BasicConsumer() = default
  + run(): void override
  - handle_test_data(message: const Message&): void
  - parse_test_data(message: const Message&, out_value: int&, out_counter: uint32_t&): bool
}

class BasicProducer <<Component>> {
  - _rng: std::mt19937
  - _value_dist: std::uniform_int_distribution<int>
  - _current_value: int
  - _counter: uint32_t
  + {static inline} const PORT: unsigned int = 105
  + BasicProducer(vehicle: Vehicle*, vehicle_id: const unsigned int, name: const std::string&, protocol: VehicleProt*)
  + ~BasicProducer() = default
  + run(): void override
  # produce_data_for_response(type: DataTypeId, out_value: std::vector<std::uint8_t>&): bool override
  - update_test_data(): void
}

class GatewayComponent <<Component>> {
  + {static} const PORT: unsigned int = 0
  + GatewayComponent(vehicle: Vehicle*, vehicle_id: const unsigned int, name: const std::string&, protocol: Protocol<NIC<SocketEngine, SharedMemoryEngine>>*)
  + ~GatewayComponent() = default
  + run(): void override
}

' Communicator Relationships
Communicator ..> Message : uses
Communicator ..> Buffer : uses
ConcurrentObserver <|-- Communicator

' NIC Relationships
Ethernet <|-- NIC
ConditionallyDataObserved <|-- NIC
NIC *-- "1" NICStatistics : _statistics
NIC <.. Initializer : friend
NIC ..> Buffer : uses
NIC *-- "1" SocketEngine : _external_engine
NIC *-- "1" SharedMemoryEngine : _internal_engine


' Protocol Relationships
ProtocolHeader <|-- ProtocolPacket : inherits
ProtocolNIC o-- "1" NIC : _nic
ProtocolNIC *-- "1" ConditionallyDataObserved : _observed > static
ProtocolNIC +-- "1" ProtocolHeader : nested class
ProtocolNIC +-- "1" ProtocolPacket : nested class
ProtocolNIC +-- ProtocolAddress : nested class

' Vehicle Relationships
Vehicle o-- "1" ProtocolNIC : _protocol
Vehicle o-- "1" NIC : _nic
Vehicle o-- "1" Communicator : _comms
Vehicle o-- "*" Component : _components

' Ethernet Relationships
Ethernet +-- EthernetAddress : nested class
Ethernet +-- EthernetFrame : nested class
EthernetFrame o-- "2" EthernetAddress : dst,src
Ethernet o-- "1" EthernetAddress : NULL_ADDRESS > static

' Observer Relationships
ConcurrentObserver <.. ConcurrentObserved : <<friend>>
ConditionalDataObserver -- ConditionallyDataObserved : <<observes>>
ConditionalDataObserver <|-- ConcurrentObserver
ConditionalDataObserver ..> ConditionallyDataObserved : <<friend>>
ConcurrentObserver ..> ConcurrentObserved : <<friend>>
ConcurrentObserver -- ConcurrentObserved : <<observes>>

' Observed Relationships
ConditionallyDataObserved <|-- ConcurrentObserved

' Component Relationships
Component o-- "1" Communicator : _communicator
Component o-- "1" Vehicle : _vehicle
Component <|-- BatteryComponent : inherits
Component <|-- CameraComponent : inherits
Component <|-- ECUComponent : inherits
Component <|-- LidarComponent : inherits
Component <|-- INSComponent : inherits
Component <|-- BasicConsumer : inherits
Component <|-- BasicProducer : inherits
Component <|-- GatewayComponent : inherits



@enduml
