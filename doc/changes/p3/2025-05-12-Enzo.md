# SCHED_DEADLINE Support for Producer Message Generation

## Overview

I've implemented support for Linux's `SCHED_DEADLINE` real-time scheduler for the producer message generation thread. This enhancement enables more precise timing and better determinism for the periodic messages sent by producer components.

## Motivation

The original implementation used `usleep()` for timing control in the producer response thread, which has several limitations:

- No guarantees of waking up exactly at the specified time
- Susceptible to system load and other interruptions
- Can lead to jitter (variable timing) in message delivery
- No resource reservation to ensure the thread gets enough CPU time

`SCHED_DEADLINE` solves these issues by:

- Providing deadline-based scheduling with kernel-level timing precision
- Reserving a portion of CPU time exclusively for the thread
- Minimizing jitter and ensuring deterministic behavior
- Protecting the thread from system overload conditions

## Implementation Details

### 1. Added SCHED_DEADLINE Support

I added the necessary API interfaces and structures to use the Linux kernel's SCHED_DEADLINE scheduler:

```cpp
// Define syscall numbers for SCHED_DEADLINE if not already defined
#ifndef SCHED_DEADLINE
#define SCHED_DEADLINE 6
#endif

#ifndef __NR_sched_setattr
#ifdef __x86_64__
#define __NR_sched_setattr 314
#define __NR_sched_getattr 315
#elif __i386__
#define __NR_sched_setattr 351
#define __NR_sched_getattr 352
#elif __arm__
#define __NR_sched_setattr 380
#define __NR_sched_getattr 381
#elif __aarch64__
#define __NR_sched_setattr 274
#define __NR_sched_getattr 275
#endif
#endif

// Define struct for sched_attr if not already defined
struct sched_attr {
    __u32 size;
    __u32 sched_policy;
    __u64 sched_flags;
    __s32 sched_nice;
    __u32 sched_priority;
    __u64 sched_runtime;
    __u64 sched_deadline;
    __u64 sched_period;
};

// Define syscall functions for sched_deadline
static inline int sched_setattr(pid_t pid, const struct sched_attr *attr, unsigned int flags) {
    return syscall(__NR_sched_setattr, pid, attr, flags);
}

static inline int sched_getattr(pid_t pid, struct sched_attr *attr, unsigned int size, unsigned int flags) {
    return syscall(__NR_sched_getattr, pid, attr, size, flags);
}
```

### 2. Added Capability Detection

Added a method to test if the process has the necessary `CAP_SYS_NICE` capability to use SCHED_DEADLINE:

```cpp
bool Component::has_deadline_scheduling_capability() {
    // Try to set SCHED_DEADLINE parameters with minimal values
    struct sched_attr attr;
    memset(&attr, 0, sizeof(attr));
    attr.size = sizeof(attr);
    attr.sched_policy = SCHED_DEADLINE;
    attr.sched_runtime = 1000;        // 1 microsecond runtime
    attr.sched_period = 10000;        // 10 microsecond period
    attr.sched_deadline = 10000;      // 10 microsecond deadline
    
    // Try setting it on current thread temporarily
    int result = sched_setattr(0, &attr, 0);
    
    // If it works, reset back to normal
    if (result == 0) {
        struct sched_param param;
        param.sched_priority = 0;
        pthread_setschedparam(pthread_self(), SCHED_OTHER, &param);
        return true;
    }
    
    // If EPERM, we don't have the capability
    if (errno == EPERM) {
        db<Component>(WRN) << "Component " << getName() 
                         << " lacks CAP_SYS_NICE capability for SCHED_DEADLINE. "
                         << "Consider using: sudo setcap cap_sys_nice+ep <executable>\n";
    } else {
        db<Component>(WRN) << "Component " << getName()
                         << " SCHED_DEADLINE test failed with error: " << errno << "\n";
    }
    
    return false;
}
```

### 3. Modified Producer Response Thread

Updated the producer response routine to use SCHED_DEADLINE when available, with a fallback to the original usleep-based timing:

```cpp
if (_has_dl_capability.load()) {
    // Set up SCHED_DEADLINE parameters based on our GCD period
    struct sched_attr attr;
    memset(&attr, 0, sizeof(attr));
    attr.size = sizeof(attr);
    attr.sched_policy = SCHED_DEADLINE;
    
    // Runtime is the execution time allocated for this task (in ns)
    // We'll allocate 80% of the period for runtime to be safe
    uint64_t runtime_ns = (current_period * 1000) * 0.8;
    
    // Period and deadline are set to the GCD period (in ns)
    uint64_t period_ns = current_period * 1000;
    
    attr.sched_runtime = runtime_ns;
    attr.sched_period = period_ns;
    attr.sched_deadline = period_ns; // deadline = period for our use case
    
    // Apply SCHED_DEADLINE to current thread
    int ret = sched_setattr(0, &attr, 0);
    if (ret < 0) {
        // Fall back to usleep-based timing if setting SCHED_DEADLINE fails
    } else {
        // Using SCHED_DEADLINE for timing - the kernel will handle the scheduling
        
        while (_producer_thread_running.load() && _current_gcd_period_us.load() == current_period) {
            // Generate response data
            // Send message
            
            // Let the SCHED_DEADLINE scheduler handle the timing
            sched_yield();
        }
        
        // Reset to normal scheduling when we exit the inner loop
        struct sched_param param;
        param.sched_priority = 0;
        pthread_setschedparam(pthread_self(), SCHED_OTHER, &param);
    }
}
```

### 4. Thread Class Member and Initialization

Added a class member to store the SCHED_DEADLINE capability state and properly initialize it:

```cpp
// Component class member
std::atomic<bool> _has_dl_capability {false}; // Store SCHED_DEADLINE capability state

// In start_producer_response_thread():
_has_dl_capability.store(has_deadline_scheduling_capability());
if (_has_dl_capability.load()) {
    db<Component>(INF) << "Component " << getName() << " has SCHED_DEADLINE capability.\n";
} else {
    db<Component>(WRN) << "Component " << getName() << " will fall back to usleep-based timing.\n";
}
```

## Explanation of SCHED_DEADLINE Parameters

The SCHED_DEADLINE scheduler uses three key parameters:

1. `runtime` - The amount of CPU time allocated to the task during each period (in nanoseconds)
2. `deadline` - The deadline by which the runtime must be completed (in nanoseconds)
3. `period` - The repeating cycle time (in nanoseconds)

For our implementation:
- `runtime` is set to 80% of the GCD period (to ensure we have enough CPU time)
- `deadline` equals the GCD period (message must be sent within one period)
- `period` equals the GCD period (matches the consumer interest periods)

## Usage Instructions

The SCHED_DEADLINE support requires the `CAP_SYS_NICE` capability to function. There are two ways to enable this:

1. **Run the program as root (not recommended):**
   ```
   sudo ./your_executable
   ```

2. **Grant the necessary capability to the executable (recommended):**
   ```
   sudo setcap cap_sys_nice+ep ./your_executable
   ```

The capability can be verified with:
```
getcap ./your_executable
```

When properly set up, the system will automatically use SCHED_DEADLINE for the producer threads. If the capability is missing, it will gracefully fall back to the original usleep-based timing.

## Benefits

1. **Improved Timing Precision**: Messages are sent with much better timing accuracy
2. **Reduced Jitter**: Variation in message timing is minimized
3. **Resource Reservation**: The thread is guaranteed CPU time regardless of system load
4. **Priority Protection**: Higher priority tasks won't starve the producer thread
5. **Graceful Degradation**: Falls back to the original method when capabilities are missing

## Future Improvements

Potential future enhancements could include:

1. Using `CLOCK_MONOTONIC` absolute timer-based wakeups in the fallback path for improved precision
2. Adding configurable runtime percentages for different producer types
3. Implementing runtime monitoring to detect timing violations
4. Adding performance statistics to track actual vs. expected timing 