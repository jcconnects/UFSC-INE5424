# P3 Implementation - Phase 1: Core Definitions and Structures

## Overview

This document details the changes made during Phase 1 of the P3 implementation, which focuses on establishing the core definitions, data structures, and method signatures for the time-triggered publish-subscribe communication system. The phase lays the groundwork for the subsequent implementation phases.

## Changes

### 1. `DataTypeId` Enum and Message Types (Step 1)

#### `include/teds.h` (New)
- Created a new header file defining `DataTypeId` as a strongly-typed enum for message type identifiers.
- Added various data type IDs including `VEHICLE_SPEED`, `ENGINE_RPM`, `OBSTACLE_DISTANCE`, and others.
- Added `SYSTEM_INTERNAL_REG_PRODUCER` for gateway registration messages.

```cpp
enum class DataTypeId : std::uint32_t {
    UNKNOWN = 0,
    VEHICLE_SPEED,
    ENGINE_RPM,
    OBSTACLE_DISTANCE,
    // ...
    SYSTEM_INTERNAL_REG_PRODUCER, // For Gateway registration
    // ...
};
```

#### `include/message.h` (Modified)
- Added `#include "teds.h"` to access `DataTypeId`.
- Extended `Message::Type` enum to include `REG_PRODUCER` type:
  ```cpp
  enum class Type : std::uint8_t {
      INTEREST,
      RESPONSE,
      REG_PRODUCER, // New type for producer registration
      // ...
  };
  ```
- Changed the message's `_unit_type` member from `std::uint32_t` to `DataTypeId`.
- Updated serialization/deserialization to handle `DataTypeId`.
- Added `value_size()` method for safer access to response payload size.
- Made the main constructor public for testing purposes while keeping the default constructor private.

#### `include/communicator.h` (Modified)
- Updated `Communicator::new_message` method to accept `DataTypeId` for message types.
- Added case handling for the new `REG_PRODUCER` message type.
- Modified existing usage to pass appropriate `DataTypeId` values.

#### `tests/unit_tests/message_test.cpp` (Modified)
- Completely rewrote to test the new P3 message structure, including all message types:
  - `INTEREST` messages with periods
  - `RESPONSE` messages with values
  - `REG_PRODUCER` messages
- Added tests for serialization and deserialization to ensure data integrity.

### 2. Component Base Class - Core P3 Threading & Data Members (Step 2)

#### `include/component.h` (Modified)
- Added necessary includes: `teds.h` and `observed.h`.
- Added forward declaration for `TypedDataHandler`.
- Added P3 core members:
  ```cpp
  Conditionally_Data_Observed<Message, DataTypeId> _internal_typed_observed;
  pthread_t _component_dispatcher_thread_id {0};
  std::atomic<bool> _dispatcher_running {false};
  ```

- Added consumer-specific members:
  ```cpp
  std::vector<std::unique_ptr<TypedDataHandler>> _typed_data_handlers;
  std::vector<pthread_t> _handler_threads_ids;
  struct InterestRequest {
      DataTypeId type;
      std::uint32_t period_us;
      std::uint64_t last_accepted_response_time_us = 0;
      bool interest_sent = false;
      std::function<void(const Message&)> callback;
  };
  std::vector<InterestRequest> _active_interests;
  ```

- Added producer-specific members:
  ```cpp
  DataTypeId _produced_data_type = DataTypeId::UNKNOWN;
  std::vector<std::uint32_t> _received_interest_periods;
  std::atomic<std::uint32_t> _current_gcd_period_us {0};
  pthread_t _producer_response_thread_id {0};
  std::atomic<bool> _producer_thread_running {false};
  ```

- Updated existing `send` and `receive` methods to use `DataTypeId::UNKNOWN` instead of 0.
- Replaced `std::filesystem` functions with basic `stat` and `mkdir` operations for broader compatibility.

### 3. Component Base Class - P3 Method Signatures (Step 3)

#### `include/component.h` (Modified)
- Added public method signature for interest registration:
  ```cpp
  void register_interest_handler(DataTypeId type, std::uint32_t period_us, std::function<void(const Message&)> callback);
  ```

- Added dispatcher methods:
  ```cpp
  static void* component_dispatcher_launcher(void* context);
  void component_dispatcher_routine();
  ```

- Added producer methods:
  ```cpp
  static void* producer_response_launcher(void* context);
  void producer_response_routine();
  void start_producer_response_thread();
  void stop_producer_response_thread();
  void update_gcd_period();
  static std::uint32_t calculate_gcd(std::uint32_t a, std::uint32_t b);
  ```

- Added virtual method for data generation:
  ```cpp
  virtual bool produce_data_for_response(DataTypeId type, std::vector<std::uint8_t>& out_value) { return false; }
  ```

### 4. TypedDataHandler Class (Step 4)

#### `include/TypedDataHandler.h` (New)
- Created a new header file for type-specific message handling.
- Defined `TypedDataHandler` class inheriting from `Concurrent_Observer<Message, DataTypeId>`.
- Added constructor taking:
  - `DataTypeId type` - The type this handler processes
  - `std::function<void(const Message&)> callback_func` - User callback
  - `Component* parent_component` - Owning component
  - `Conditionally_Data_Observed<Message, DataTypeId>* observed` - Observable
- Declared destructor for proper cleanup.
- Defined thread management methods:
  - `start_processing_thread()`
  - `stop_processing_thread()`
  - `get_thread_id()`
- Declared private processing methods:
  - `static void* processing_loop_entry(void* arg)`
  - `void processing_loop()`
- Added private member variables.

# P3 Implementation - Phase 2: Core Logic Implementation

## Overview

This phase focuses on implementing the core logic for the time-triggered publish-subscribe system based on the structures defined in Phase 1. This includes implementing type-specific message handlers, component dispatcher and consumer logic, message filtering in the Communicator, and producer response mechanisms.

## Changes

### 1. TypedDataHandler Implementation (Step 1)

#### `include/TypedDataHandler.h` (Completed)
- Implemented the constructor to initialize all members and attach to the observed object:
  ```cpp
  TypedDataHandler::TypedDataHandler(DataTypeId type, 
                   std::function<void(const Message&)> callback_func, 
                   Component* parent_component,
                   Conditionally_Data_Observed<Message, DataTypeId>* observed)
  : _callback_func(callback_func),
    _parent_component(parent_component),
    _handler_running(false),
    _thread_id(0),
    _type(type),
    _observed(observed)
  {
      if (_observed) {
          _observed->attach(this, _type);
      }
  }
  ```

- Implemented destructor to handle proper thread cleanup and observer detachment:
  ```cpp
  TypedDataHandler::~TypedDataHandler() {
      if (_handler_running.load()) {
          stop_processing_thread();
      }
      if (_observed) {
          _observed->detach(this, _type);
      }
  }
  ```

- Implemented thread management methods:
  - `start_processing_thread()`: Creates a new thread running the processing loop
  - `stop_processing_thread()`: Signals the thread to stop and wakes it up
  - `get_thread_id()`: Returns the thread ID for joining operations

- Implemented the processing methods:
  - `processing_loop_entry()`: Static entry point for pthread
  - `processing_loop()`: Main processing loop that waits for messages, executes callbacks, and handles cleanup
  ```cpp
  void TypedDataHandler::processing_loop() {
      while (_handler_running.load()) {
          // Wait for a message to be delivered
          Message* msg = Concurrent_Observer<Message, DataTypeId>::updated();
          
          // Check if we should still be running
          if (!_handler_running.load()) {
              if (msg) {
                  delete msg;
              }
              break;
          }
          
          // Process the message if it's valid
          if (msg) {
              // Execute the callback with the message
              _callback_func(*msg);
              
              // Clean up the heap-allocated message
              delete msg;
          }
      }
  }
  ```

### 2. Component Dispatcher and Consumer Logic (Step 2)

#### `include/component.h` (Modified)
- Implemented `register_interest_handler()` method:
  - Creates a new InterestRequest
  - Creates and configures a TypedDataHandler
  - Starts the handler's processing thread
  - Sends the initial INTEREST message
  ```cpp
  void Component::register_interest_handler(DataTypeId type, std::uint32_t period_us, std::function<void(const Message&)> callback) {
      // Create a new interest request
      InterestRequest request;
      request.type = type;
      request.period_us = period_us;
      request.callback = callback;
      _active_interests.push_back(request);
      
      // Create and start a TypedDataHandler
      auto handler = std::make_unique<TypedDataHandler>(type, callback, this, &_internal_typed_observed);
      handler->start_processing_thread();
      _handler_threads_ids.push_back(handler->get_thread_id());
      _typed_data_handlers.push_back(std::move(handler));
      
      // Send initial interest message
      Message interest_msg = _communicator->new_message(Message::Type::INTEREST, type, period_us);
      _communicator->send(interest_msg, Address::BROADCAST);
  }
  ```

- Implemented message dispatcher thread launcher and main routine:
  ```cpp
  void* Component::component_dispatcher_launcher(void* context) {
      Component* self = static_cast<Component*>(context);
      if (self) {
          self->component_dispatcher_routine();
      }
      return nullptr;
  }
  
  void Component::component_dispatcher_routine() {
      // Receive raw messages, deserialize them, and route to appropriate handlers
      std::uint8_t raw_buffer[1024];
      while (_dispatcher_running.load()) {
          Address source;
          int recv_size = receive(raw_buffer, sizeof(raw_buffer), &source);
          
          if (recv_size > 0) {
              try {
                  Message message = Message::deserialize(raw_buffer, recv_size);
                  Message* heap_msg = new Message(message);
                  DataTypeId msg_type = heap_msg->unit_type();
                  
                  // Notify appropriate typed observers
                  bool delivered = _internal_typed_observed.notify(msg_type, heap_msg);
                  if (!delivered) {
                      delete heap_msg;
                  }
              } catch (const std::exception& e) {
                  // Handle exception
              }
          }
      }
  }
  ```

- Modified `start()` method to initialize and launch the dispatcher thread:
  ```cpp
  void Component::start() {
      // Original initialization
      _running.store(true);
      
      // Start dispatcher thread
      _dispatcher_running.store(true);
      int disp_rc = pthread_create(&_component_dispatcher_thread_id, nullptr, 
                              Component::component_dispatcher_launcher, this);
      // Error handling...
      
      // Start producer thread if needed
      if (_produced_data_type != DataTypeId::UNKNOWN) {
          start_producer_response_thread();
      }
      
      // Start main thread
      // ...
  }
  ```

- Enhanced `stop()` method to properly clean up all threads:
  ```cpp
  void Component::stop() {
      // Set flags
      _running.store(false);
      _dispatcher_running.store(false);
      
      // Stop producer thread if running
      if (_producer_thread_running.load()) {
          stop_producer_response_thread();
      }
      
      // Close communicator
      _communicator->close();
      
      // Join dispatcher thread
      // ...
      
      // Stop and join handler threads
      for (auto& handler : _typed_data_handlers) {
          handler->stop_processing_thread();
      }
      for (pthread_t thread_id : _handler_threads_ids) {
          if (thread_id != 0) {
              pthread_join(thread_id, nullptr);
          }
      }
      
      // Clear containers
      _typed_data_handlers.clear();
      _handler_threads_ids.clear();
      
      // Join main thread
      // ...
  }
  ```

### 3. Communicator P3 Filtering (Step 3)

#### `include/communicator.h` (Modified)
- Added forward declaration for Component to avoid circular dependency:
  ```cpp
  // Forward declaration for Component to avoid circular dependency
  class Component;
  ```

- Added Component owner reference and accessor:
  ```cpp
  private:
      Component* _owner_component; // Owner component reference for P3 filtering
  
  public:
      void set_owner_component(Component* owner) {
          _owner_component = owner;
      }
  ```

- Updated constructor to accept Component pointer:
  ```cpp
  Communicator(Channel* channel, Address address, Component* owner = nullptr);
  ```

- Implemented filtering logic in the `update()` method:
  ```cpp
  void Communicator<Channel>::update(typename Channel::Observed* obs, typename Channel::Observer::Observing_Condition c, Buffer* buf) {
      // Skip filtering if no buffer or no owner component
      if (!buf || !_owner_component) {
          Observer::update(c, buf);
          return;
      }
      
      try {
          // Extract message header information
          std::uint8_t temp_header[16];
          _channel->peek(buf, temp_header, 16);
          
          // Extract message type and unit type
          unsigned int offset = 0;
          Message::Type msg_type = static_cast<Message::Type>(Message::extract_uint8t(temp_header, offset, 16));
          offset = 1 + 8; // Skip type and origin
          offset += 8;    // Skip timestamp
          DataTypeId unit_type = static_cast<DataTypeId>(Message::extract_uint32t(temp_header, offset, 16));
          
          // Determine component role
          bool is_gateway = (_address.port() == 0);
          bool is_producer = (_owner_component->get_produced_data_type() != DataTypeId::UNKNOWN);
          bool is_consumer = !_owner_component->_active_interests.empty();
          
          // Apply role-specific filtering
          bool should_deliver = false;
          
          if (is_gateway) {
              // Gateway accepts all INTEREST and REG_PRODUCER messages
              should_deliver = (msg_type == Message::Type::INTEREST || msg_type == Message::Type::REG_PRODUCER);
          }
          else if (is_producer) {
              // Producer components care about INTEREST messages for their data type
              if (msg_type == Message::Type::INTEREST) {
                  DataTypeId produced_type = _owner_component->get_produced_data_type();
                  should_deliver = (unit_type == produced_type);
              }
          }
          else if (is_consumer) {
              // Consumer components care about RESPONSE messages for their interests
              if (msg_type == Message::Type::RESPONSE) {
                  // Apply period-based filtering
                  auto now = std::chrono::high_resolution_clock::now();
                  auto now_us = std::chrono::duration_cast<std::chrono::microseconds>(
                      now.time_since_epoch()).count();
                  
                  for (auto& interest : _owner_component->_active_interests) {
                      if (interest.type == unit_type) {
                          if (now_us - interest.last_accepted_response_time_us >= interest.period_us) {
                              interest.last_accepted_response_time_us = now_us;
                              should_deliver = true;
                              break;
                          }
                      }
                  }
              }
          }
          
          // Handle delivery or discard
          if (should_deliver) {
              Observer::update(c, buf);
          } else {
              _channel->free(buf);
          }
      } catch (const std::exception& e) {
          // Fall back to regular update behavior on error
          Observer::update(c, buf);
      }
  }
  ```

#### `include/component.h` (Modified)
- Added accessor methods for Communicator filtering:
  ```cpp
  DataTypeId get_produced_data_type() const { return _produced_data_type; }
  bool has_active_interests() const { return !_active_interests.empty(); }
  ```

- Added friend declaration for Communicator to access private members:
  ```cpp
  template <typename Channel>
  friend class Communicator;
  ```

### 4. Producer Logic in Component (Step 4)

#### `include/component.h` (Modified)
- Implemented producer response thread launcher and main routine:
  ```cpp
  void* Component::producer_response_launcher(void* context) {
      Component* self = static_cast<Component*>(context);
      if (self) {
          self->producer_response_routine();
      }
      return nullptr;
  }
  
  void Component::producer_response_routine() {
      while (_producer_thread_running.load()) {
          // Check if we have a valid period to use
          std::uint32_t current_period = _current_gcd_period_us.load();
          
          if (current_period > 0) {
              // Generate response data
              std::vector<std::uint8_t> response_data;
              
              if (produce_data_for_response(_produced_data_type, response_data)) {
                  // Create and send RESPONSE message
                  Message response_msg = _communicator->new_message(
                      Message::Type::RESPONSE,
                      _produced_data_type,
                      0,
                      response_data.data(),
                      response_data.size()
                  );
                  
                  _communicator->send(response_msg, Address::BROADCAST);
              }
              
              // Sleep for the current GCD period
              usleep(current_period);
          } else {
              // No valid period, sleep a bit and check again
              usleep(100000); // 100ms
          }
      }
  }
  ```

- Implemented thread management methods:
  ```cpp
  void Component::start_producer_response_thread() {
      // Only start if not already running and we're a producer
      if (!_producer_thread_running.load() && _produced_data_type != DataTypeId::UNKNOWN) {
          _producer_thread_running.store(true);
          
          int rc = pthread_create(&_producer_response_thread_id, nullptr, 
                                 Component::producer_response_launcher, this);
          // Error handling...
      }
  }
  
  void Component::stop_producer_response_thread() {
      if (_producer_thread_running.load()) {
          // Signal the thread to stop
          _producer_thread_running.store(false);
          
          // Join the thread
          if (_producer_response_thread_id != 0) {
              pthread_join(_producer_response_thread_id, nullptr);
              _producer_response_thread_id = 0;
          }
      }
  }
  ```

- Implemented GCD calculation methods:
  ```cpp
  void Component::update_gcd_period() {
      // If no periods, set GCD to 0
      if (_received_interest_periods.empty()) {
          _current_gcd_period_us.store(0);
          return;
      }
      
      // Calculate GCD of all periods
      std::uint32_t result = _received_interest_periods[0];
      for (size_t i = 1; i < _received_interest_periods.size(); ++i) {
          result = calculate_gcd(result, _received_interest_periods[i]);
      }
      
      // Store the result
      _current_gcd_period_us.store(result);
  }
  
  std::uint32_t Component::calculate_gcd(std::uint32_t a, std::uint32_t b) {
      // Handle edge cases
      if (a == 0) return b;
      if (b == 0) return a;
      
      // Euclidean algorithm
      while (b != 0) {
          std::uint32_t temp = b;
          b = a % b;
          a = temp;
      }
      
      return a;
  }
  ```

# P3 Implementation - Phase 3: Gateway and Component Integration

## Overview

Phase 3 implements the Gateway component and specialized producer/consumer components to create a complete P3 time-triggered publish-subscribe system. This phase focuses on the integration of the core logic developed in Phase 2.

## Changes

### 1. Gateway Component Implementation (Step 1)

#### `include/components/gateway_component.h` (Modified)
- Updated the port to use port 0 as the well-known port for Gateway:
  ```cpp
  const unsigned int GatewayComponent::PORT = 0; // Gateway always uses Port 0
  ```

- Added producer registry to map data types to producer ports:
  ```cpp
  // Registry mapping DataTypeId to producer ports
  std::map<DataTypeId, std::vector<Port>> _producer_registry;
  ```

- Added methods for handling specific message types:
  ```cpp
  // Helper methods to handle specific message types
  void handle_reg_producer(const Message& message);
  void handle_interest(const Message& message);
  ```

- Modified constructor to set up the communicator with Gateway's port:
  ```cpp
  // Sets own address using Port 0 (Gateway's well-known port)
  Address addr(_vehicle->address().paddr(), PORT);
  
  // Sets own communicator
  _communicator = new Comms(protocol, addr);
  if (_communicator) {
      _communicator->set_owner_component(this);
  }
  ```

- Updated the run() method to monitor registry status instead of manually processing messages:
  ```cpp
  void GatewayComponent::run() {
      // The main Gateway logic is now handled by the component_dispatcher_routine
      // This run() method just keeps the component alive and logs status periodically
      while (running()) {
          // Log current registry status
          for (const auto& entry : _producer_registry) {
              db<GatewayComponent>(INF) << "Registry: Type " << static_cast<int>(entry.first) 
                                       << " has " << entry.second.size() << " producers\n";
          }
          
          usleep(1000000); // Sleep for 1 second
      }
  }
  ```

- Implemented `handle_reg_producer()` to register producers:
  ```cpp
  void GatewayComponent::handle_reg_producer(const Message& message) {
      // Extract the DataTypeId being produced
      DataTypeId produced_type = message.unit_type();
      
      // Extract the producer's port from the message's origin
      Port producer_port = message.origin().port();
      
      // Add to registry (checking for duplicates)
      bool already_registered = false;
      auto& ports = _producer_registry[produced_type];
      
      for (const auto& port : ports) {
          if (port == producer_port) {
              already_registered = true;
              break;
          }
      }
      
      if (!already_registered) {
          ports.push_back(producer_port);
          db<GatewayComponent>(INF) << "Registered producer for type " << static_cast<int>(produced_type) 
                                   << " on port " << producer_port << " from " 
                                   << message.origin().to_string() << "\n";
      }
  }
  ```

- Implemented `handle_interest()` to relay interest messages:
  ```cpp
  void GatewayComponent::handle_interest(const Message& message) {
      // Extract the DataTypeId being requested
      DataTypeId requested_type = message.unit_type();
      
      // Extract the requested period
      std::uint32_t period = message.period();
      
      // Check if we have any registered producers for this type
      if (_producer_registry.count(requested_type) > 0) {
          const auto& producer_ports = _producer_registry[requested_type];
          
          if (producer_ports.empty()) {
              db<GatewayComponent>(WRN) << "No producers registered for type " 
                                      << static_cast<int>(requested_type) << "\n";
              return;
          }
          
          // Relay the interest to each registered producer
          for (const auto& target_producer_port : producer_ports) {
              // Create a new interest message
              Message internal_interest = _communicator->new_message(
                  Message::Type::INTEREST,
                  requested_type,
                  period
              );
              
              // Send to the specific producer
              Address target(_vehicle->address().paddr(), target_producer_port);
              _communicator->send(internal_interest, target);
              
              db<GatewayComponent>(INF) << "Gateway relayed INTEREST for type " 
                                      << static_cast<int>(requested_type) 
                                      << " to internal port " << target_producer_port << "\n";
          }
      }
  }
  ```

### 2. Lidar Component as Producer (Step 2)

#### `include/components/lidar_component.h` (Modified)
- Added data structure for obstacle distance data:
  ```cpp
  struct ObstacleDistanceData {
      float distance_meters;
      float angle_degrees;
      uint8_t confidence; // 0-100
      
      // Serialization and deserialization helpers
      static std::vector<std::uint8_t> serialize(const ObstacleDistanceData& data);
      static ObstacleDistanceData deserialize(const std::vector<std::uint8_t>& bytes);
  };
  ```

- Modified constructor to initialize as a producer of `OBSTACLE_DISTANCE` data:
  ```cpp
  // Initialize as a producer of OBSTACLE_DISTANCE data
  _produced_data_type = DataTypeId::OBSTACLE_DISTANCE;
  ```

- Updated the run() method to register with Gateway:
  ```cpp
  // Send REG_PRODUCER message to Gateway
  Message reg_msg = _communicator->new_message(
      Message::Type::REG_PRODUCER,
      _produced_data_type
  );
  
  // Send to Gateway (port 0)
  Address gateway_addr(_vehicle->address().paddr(), 0);
  _communicator->send(reg_msg, gateway_addr);
  ```

- Implemented produce_data_for_response() to generate obstacle data:
  ```cpp
  bool LidarComponent::produce_data_for_response(DataTypeId type, std::vector<std::uint8_t>& out_value) {
      // Only respond to requests for our produced data type
      if (type != DataTypeId::OBSTACLE_DISTANCE) {
          return false;
      }
      
      // Serialize the current obstacle data
      out_value = ObstacleDistanceData::serialize(_current_data);
      
      return true;
  }
  ```

### 3. Camera Component as Producer (Step 3)

#### `include/components/camera_component.h` (Modified)
- Converted from consumer to producer of `TEMPERATURE_SENSOR` data
- Added data structure for temperature data:
  ```cpp
  struct TemperatureData {
      float temperature_celsius;
      float humidity_percent;
      uint8_t status; // 0-255 (status codes)
      
      // Serialization and deserialization helpers
      static std::vector<std::uint8_t> serialize(const TemperatureData& data);
      static TemperatureData deserialize(const std::vector<std::uint8_t>& bytes);
  };
  ```

- Modified constructor to initialize as a producer:
  ```cpp
  // Initialize as a producer of TEMPERATURE_SENSOR data
  _produced_data_type = DataTypeId::TEMPERATURE_SENSOR;
  ```

- Implemented produce_data_for_response() method:
  ```cpp
  bool CameraComponent::produce_data_for_response(DataTypeId type, std::vector<std::uint8_t>& out_value) {
      // Only respond to requests for our produced data type
      if (type != DataTypeId::TEMPERATURE_SENSOR) {
          return false;
      }
      
      // Serialize the current temperature data
      out_value = TemperatureData::serialize(_current_data);
      
      return true;
  }
  ```

### 4. Battery Component as Producer (Step 4)

#### `include/components/battery_component.h` (Modified)
- Converted from legacy component to producer of `ENGINE_RPM` data
- Added data structure for battery status:
  ```cpp
  struct BatteryStatusData {
      float voltage_v;
      float current_a;
      float temperature_c;
      float soc_percent;  // State of Charge percentage
      
      // Serialization and deserialization helpers
      static std::vector<std::uint8_t> serialize(const BatteryStatusData& data);
      static BatteryStatusData deserialize(const std::vector<std::uint8_t>& bytes);
  };
  ```

- Modified constructor to initialize as a producer:
  ```cpp
  // Initialize as a producer of ENGINE_RPM data
  _produced_data_type = DataTypeId::ENGINE_RPM;
  ```

- Implemented produce_data_for_response() method:
  ```cpp
  bool BatteryComponent::produce_data_for_response(DataTypeId type, std::vector<std::uint8_t>& out_value) {
      // Only respond to requests for our produced data type
      if (type != DataTypeId::ENGINE_RPM) {
          return false;
      }
      
      // Serialize the current battery data
      out_value = BatteryStatusData::serialize(_current_data);
      
      return true;
  }
  ```

### 5. INS Component as Producer (Step 5)

#### `include/components/ins_component.h` (Modified)
- Converted from legacy component to producer of `GPS_POSITION` data
- Added data structure for GPS position:
  ```cpp
  struct GPSPositionData {
      double latitude_rad;   // Latitude in radians (-PI/2 to PI/2)
      double longitude_rad;  // Longitude in radians (-PI to PI)
      double altitude_m;     // Altitude in meters
      double velocity_mps;   // Velocity in meters per second
      double heading_rad;    // Heading in radians (0 to 2*PI)
      
      // Serialization and deserialization helpers
      static std::vector<std::uint8_t> serialize(const GPSPositionData& data);
      static GPSPositionData deserialize(const std::vector<std::uint8_t>& bytes);
  };
  ```

- Modified constructor to initialize as a producer:
  ```cpp
  // Initialize as a producer of GPS_POSITION data
  _produced_data_type = DataTypeId::GPS_POSITION;
  ```

- Implemented produce_data_for_response() method:
  ```cpp
  bool INSComponent::produce_data_for_response(DataTypeId type, std::vector<std::uint8_t>& out_value) {
      // Only respond to requests for our produced data type
      if (type != DataTypeId::GPS_POSITION) {
          return false;
      }
      
      // Serialize the current GPS position data
      out_value = GPSPositionData::serialize(_current_data);
      
      return true;
  }
  ```

### 6. ECU Component as Consumer (Step 6)

#### `include/components/ecu_component.h` (Modified)
- Converted ECU into a consumer component
- Added interest period constant:
  ```cpp
  // Interest period for requesting obstacle data (in microseconds)
  static const std::uint32_t OBSTACLE_DATA_PERIOD_US = 300000; // 300ms
  ```

- Added data structure for storing latest received obstacle data:
  ```cpp
  // Latest received obstacle data
  struct {
      float distance_meters = 0.0f;
      float angle_degrees = 0.0f;
      uint8_t confidence = 0;
      bool data_valid = false;
      std::chrono::time_point<std::chrono::high_resolution_clock> last_update;
      std::mutex mutex;
  } _latest_obstacle_data;
  ```

- Updated run() method to register interest in obstacle data:
  ```cpp
  // Register interest in obstacle distance data
  register_interest_handler(
      DataTypeId::OBSTACLE_DISTANCE, 
      OBSTACLE_DATA_PERIOD_US,
      [this](const Message& msg) { 
          this->handle_obstacle_data(msg);
      }
  );
  ```

- Implemented handler for obstacle data:
  ```cpp
  void ECUComponent::handle_obstacle_data(const Message& message) {
      // Parse the obstacle data from the message
      ObstacleData data;
      if (!parse_obstacle_data(message, data)) {
          db<ECUComponent>(WRN) << "ECU received invalid obstacle data message\n";
          return;
      }
      
      // Update the latest obstacle data
      {
          std::lock_guard<std::mutex> lock(_latest_obstacle_data.mutex);
          _latest_obstacle_data.distance_meters = data.distance_meters;
          _latest_obstacle_data.angle_degrees = data.angle_degrees;
          _latest_obstacle_data.confidence = data.confidence;
          _latest_obstacle_data.data_valid = true;
          _latest_obstacle_data.last_update = std::chrono::high_resolution_clock::now();
      }
  }
  ```

- Added vehicle control logic in the main loop:
  ```cpp
  // Here the ECU would perform vehicle control based on the obstacle data
  if (current_data.distance_meters < 10.0f && current_data.confidence > 80) {
      db<ECUComponent>(INF) << "ECU " << getName() << " ALERT: Obstacle within 10m - taking action!\n";
      // Simulate vehicle control action
  }
  ```

## Summary of Phase 3

Phase 3 successfully implemented:

1. A Gateway component that maintains a registry of producers and relays interest messages.
2. Four producer components:
   - LidarComponent producing OBSTACLE_DISTANCE data
   - CameraComponent producing TEMPERATURE_SENSOR data
   - BatteryComponent producing ENGINE_RPM data
   - INSComponent producing GPS_POSITION data
3. One consumer component:
   - ECUComponent consuming OBSTACLE_DISTANCE data
4. Complete end-to-end publish-subscribe flow:
   - Producers register with Gateway
   - Consumer sends Interest to Gateway
   - Gateway relays Interest to appropriate Producers
   - Producers send periodic Responses
   - Consumer processes Responses and takes actions

The implementation demonstrates the complete P3 time-triggered publish-subscribe communication system with proper component role separation and message filtering.

# P3 Implementation - Phase 4: Improvements and Optimizations

## Overview

Phase 4 focuses on improving and optimizing the implementation based on the initial deployment and testing. Two key improvements were implemented to address gaps in the original implementation, enhancing both efficiency and correctness of the system.

## Improvements

### 1. Enhanced Producer INTEREST Handling

#### Issue Identified:
While the Communicator filtering correctly passed INTEREST messages to producer components, there was no clear mechanism in the component_dispatcher_routine to process these messages for updating the GCD period. This resulted in producers not properly updating their response periods based on consumer interests.

#### Solution:
Enhanced the Component::component_dispatcher_routine to directly handle INTEREST messages that match a producer's own data type:

```cpp
// In Component::component_dispatcher_routine
// After deserializing the received message:
if (_produced_data_type != DataTypeId::UNKNOWN && 
    message.message_type() == Message::Type::INTEREST &&
    message.unit_type() == _produced_data_type) {
    
    // Add this period to our received_interest_periods if not already present
    std::uint32_t requested_period = message.period();
    bool period_exists = false;
    
    for (std::uint32_t existing_period : _received_interest_periods) {
        if (existing_period == requested_period) {
            period_exists = true;
            break;
        }
    }
    
    if (!period_exists) {
        _received_interest_periods.push_back(requested_period);
        // Update the GCD period
        update_gcd_period();
        
        db<Component>(INF) << "Producer " << getName() << " received INTEREST for type " 
                          << static_cast<int>(_produced_data_type) << " with period " 
                          << requested_period << "us. New GCD: " 
                          << _current_gcd_period_us.load() << "us\n";
    }
}
```

This change ensures that producer components directly process INTEREST messages for their produced data type, updating the GCD period appropriately before the message is passed to type handlers.

### 2. Gateway Component Dispatcher Override

#### Issue Identified:
The GatewayComponent was relying on the base Component's dispatcher and needed to register handlers for all possible DataTypeId values to properly process REG_PRODUCER and INTEREST messages. This was inefficient and potentially fragile.

#### Solution:
Overrode the component_dispatcher_routine in GatewayComponent to directly process messages based on their type:

```cpp
void GatewayComponent::component_dispatcher_routine() override {
    db<GatewayComponent>(TRC) << "Gateway " << getName() << " dispatcher routine started.\n";
    
    // Buffer for raw messages
    std::uint8_t raw_buffer[1024];
    
    while (_dispatcher_running.load()) {
        // Receive raw message
        Address source;
        int recv_size = receive(raw_buffer, sizeof(raw_buffer), &source);
        
        if (recv_size <= 0) {
            // Check if we should exit or handle error...
            continue;
        }
        
        try {
            // Get current time for latency measurement
            auto recv_time = std::chrono::duration_cast<std::chrono::microseconds>(
                std::chrono::high_resolution_clock::now().time_since_epoch());
            
            // Deserialize raw message
            Message message = Message::deserialize(raw_buffer, recv_size);
            
            // Process the message directly based on its type
            if (message.message_type() == Message::Type::REG_PRODUCER) {
                handle_reg_producer(message);
            } 
            else if (message.message_type() == Message::Type::INTEREST) {
                handle_interest(message);
            }
            else {
                db<GatewayComponent>(WRN) << "Gateway received unhandled message type: " 
                                         << static_cast<int>(message.message_type()) << "\n";
            }
            
            // Log the message receipt
            // ...
            
        } catch (const std::exception& e) {
            db<GatewayComponent>(ERR) << "Gateway " << getName() << " dispatcher exception: " << e.what() << "\n";
        }
    }
}
```

This change ensures the Gateway can efficiently handle all REG_PRODUCER and INTEREST messages without requiring complex handler registration. It directly calls the appropriate handling methods based on message type.

## Summary of Phase 4

These improvements address important gaps in the initial implementation:

1. **Producer GCD Update Mechanism**: Producers now properly detect and process INTEREST messages, updating their GCD period based on consumer requests.

2. **Efficient Gateway Message Processing**: The Gateway now directly processes all registration and interest messages, eliminating the need for complex handler registration for different data types.

These changes enhance the robustness and correctness of the P3 time-triggered publish-subscribe system, ensuring producers respond at appropriate rates based on consumer interests and that the Gateway correctly manages the producer registry and interest relaying.

The implementation now fully aligns with the design specified in the implementation plan and communication flow diagram. 