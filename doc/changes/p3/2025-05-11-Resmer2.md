---
title: "Compilation Error Fixes"
date: 2025-05-11
---

# P3 Communicator Changes

## Overview
This document summarizes the changes made to the Communicator class in order to solve its circular dependency with Component.

### Adopted Changes

**ComponentType Enum Class** The enum class now has its own separate header

**Communicator** THe class now has attributes that represent the owner instead of a direct pointer to the owner. The attributes should be managed by the owner component to ensure the Communicator is updated (TODO)

Attributes:
```cpp
template <typename Channel>
class Communicator: public Concurrent_Observer<typename Channel::Observer::Observed_Data, typename Channel::Observer::Observing_Condition>
{
    ...
    private:
        ...
        ComponentType _owner_type;
        DataTypeId _owner_data_type;
        std::vector<Interest> _interests; // List of interests for filtering
        ...
};
```

Managing Methods:

```cpp

template <typename Channel>
bool Communicator<Channel>::add_interest(DataTypeId type) {
    db<Communicator>(TRC) << "Communicator<Channel>::add_interest() called!\n";
    
    // Check if the interest already exists
    for (const auto& interest : _interests) {
        if (interest.type == type) {
            db<Communicator>(WRN) << "[Communicator] Interest already exists for type " << static_cast<int>(type) << "\n";
            return false;
        }
    }
    
    // Add new interest
    _interests.push_back({type, 0});
    db<Communicator>(INF) << "[Communicator] Interest added for type " << static_cast<int>(type) << "\n";
    return true;
}

template <typename Channel>
bool Communicator<Channel>::remove_interest(DataTypeId type) {
    db<Communicator>(TRC) << "Communicator<Channel>::remove_interest() called!\n";
    
    // Find and remove the interest
    auto it = std::remove_if(_interests.begin(), _interests.end(), 
                             [type](const Interest& interest) { return interest.type == type; });
    
    if (it != _interests.end()) {
        _interests.erase(it, _interests.end());
        db<Communicator>(INF) << "[Communicator] Interest removed for type " << static_cast<int>(type) << "\n";
        return true;
    }
    
    db<Communicator>(WRN) << "[Communicator] No interest found for type " << static_cast<int>(type) << "\n";
    return false;
}

template <typename Channel>
void Communicator<Channel>::clear_interests() { _interests.clear(); }

```