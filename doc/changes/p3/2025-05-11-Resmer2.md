---
title: "Compilation Error Fixes"
date: 2025-05-11
---

# P3 Communicator Changes

## Overview
This document summarizes the changes made to the Communicator class in order to solve its circular dependency with Component.

### Adopted Changes

**ComponentType Enum Class** The enum class now has its own separate header

**Communicator** The class now has attributes that represent the owner instead of a direct pointer to the owner. The attributes should be managed by the owner component to ensure the Communicator is updated (TODO)

Attributes:
```cpp
template <typename Channel>
class Communicator: public Concurrent_Observer<typename Channel::Observer::Observed_Data, typename Channel::Observer::Observing_Condition>
{
    ...
    private:
        ...
        ComponentType _owner_type;
        DataTypeId _owner_data_type;
        std::vector<Interest> _interests; // List of interests for filtering
        ...
};
```

Managing Methods:

```cpp

template <typename Channel>
bool Communicator<Channel>::add_interest(DataTypeId type) {
    db<Communicator>(TRC) << "Communicator<Channel>::add_interest() called!\n";
    
    // Check if the interest already exists
    for (const auto& interest : _interests) {
        if (interest.type == type) {
            db<Communicator>(WRN) << "[Communicator] Interest already exists for type " << static_cast<int>(type) << "\n";
            return false;
        }
    }
    
    // Add new interest
    _interests.push_back({type, 0});
    db<Communicator>(INF) << "[Communicator] Interest added for type " << static_cast<int>(type) << "\n";
    return true;
}

template <typename Channel>
bool Communicator<Channel>::remove_interest(DataTypeId type) {
    db<Communicator>(TRC) << "Communicator<Channel>::remove_interest() called!\n";
    
    // Find and remove the interest
    auto it = std::remove_if(_interests.begin(), _interests.end(), 
                             [type](const Interest& interest) { return interest.type == type; });
    
    if (it != _interests.end()) {
        _interests.erase(it, _interests.end());
        db<Communicator>(INF) << "[Communicator] Interest removed for type " << static_cast<int>(type) << "\n";
        return true;
    }
    
    db<Communicator>(WRN) << "[Communicator] No interest found for type " << static_cast<int>(type) << "\n";
    return false;
}

template <typename Channel>
void Communicator<Channel>::clear_interests() { _interests.clear(); }

```

**GatewayComponent now implements its own specific_start()** In order to start its specific routine the class now implements a specific_start() method overriding virtual void Component::specific_start().

```cpp

void* GatewayComponent::component_dispatcher_launcher(void* context) {
    GatewayComponent* self = static_cast<GatewayComponent*>(context);
    if (self) {
        db<GatewayComponent>(INF) << "Component GatewayComponent dispatcher thread starting.\n";
        self->component_dispatcher_routine();
        db<GatewayComponent>(INF) << "Component GatewayComponent dispatcher thread exiting.\n";
    }
    return nullptr;
}

void GatewayComponent::specific_start() {
    db<GatewayComponent>(TRC) << "GatewayComponent::start() called.\n";

    if (running()) {
        db<GatewayComponent>(WRN) << "[GatewayComponent] start() called when GatewayComponent is already running.\n";
        return;
    }

    _running.store(true, std::memory_order_release);
    
    // Start dispatcher thread
    _dispatcher_running.store(true);
    int disp_rc = pthread_create(&_component_dispatcher_thread_id, nullptr, 
                                component_dispatcher_launcher, this);
    if (disp_rc) {
        db<GatewayComponent>(ERR) << "[GatewayComponent] Failed to create dispatcher thread for " << getName() 
                          << ", error code: " << disp_rc << "\n";
        _dispatcher_running.store(false);
        _running.store(false);
        throw std::runtime_error("Failed to create dispatcher thread for " + getName());
    }
    db<GatewayComponent>(INF) << "GatewayComponent GatewayComponent dispatcher thread created successfully.\n";
    
    // Check if this is a producer component and start producer thread if needed
    if (_produced_data_type != DataTypeId::UNKNOWN) {
        start_producer_response_thread();
    }

    // Create main thread for run() method
    int rc = pthread_create(&_thread, nullptr, Component::thread_entry_point, this);
    if (rc) {
        db<GatewayComponent>(ERR) << "[GatewayComponent] return code from pthread_create() is " << rc << " for GatewayComponent\n";
        
        // Clean up dispatcher thread if main thread creation fails
        _dispatcher_running.store(false);
        pthread_join(_component_dispatcher_thread_id, nullptr);
        _component_dispatcher_thread_id = 0;
        
        // Stop producer thread if it was started
        if (_producer_thread_running.load()) {
            stop_producer_response_thread();
        }
        
        _running.store(false);
        throw std::runtime_error("Failed to create component thread for GatewayComponent");
    }
    db<GatewayComponent>(INF) << "GatewayComponent GatewayComponent thread created successfully.\n";
}

```