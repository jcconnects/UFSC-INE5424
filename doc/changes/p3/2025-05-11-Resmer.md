---
title: ""
date: 2025-05-11
---

## Overview

This Document details the changes made in order to promote correctness in the system following Phase 1 of the P3 implementation (detailed in 2025-05-08-Enzo.md). 

## Fixed Compilation Errors 

### Buffer Test

**File:** tests/unit_tets/buffer_test

**Error:**
```shell
tests/unit_tests/buffer_test.cpp:91:40: error: no matching function for call to ‘Buffer<TestBuffer::TestData>::Buffer(TestBuffer::TestData*, long unsigned int)’
   91 |     BufferT buf(&data, sizeof(TestData));
      |                                        ^
```

**Fix:**
```cpp
void TestBuffer::test_create_buffer_with_data() {
    // Inline Fixture
    TestData data;
    data.value1 = 1;
    data.value2 = "teste";
    data.value3 = 3.14;

    // Exercise SUT
    BufferT buf;
    buf.setData(&data, sizeof(TestData));

    // Result Verification
    assert_equal(buf.size(), sizeof(TestData), "Buffer size is different of data size!");
}
```

### Protocol Test

**File:** tests/integration_tests/protocol_test.cpp

**Error:**
```shell
tests/integration_tests/protocol_test.cpp: In function ‘int main()’:
tests/integration_tests/protocol_test.cpp:271:70: error: cannot convert ‘Protocol<NIC<ProtocolTestEngine, ProcolTestEngine2> >::Address’ to ‘Protocol<NIC<ProtocolTestEngine, ProcolTestEngine2> >::Address*’
  271 |         int bytes_received = proto2->receive(observer2->last_buffer, src_addr, received_large.data(), received_large.size());
      |                                                                      ^~~~~~~~
      |                                                                      |
      |                                                                      Protocol<NIC<ProtocolTestEngine, ProcolTestEngine2> >::Address
In file included from tests/integration_tests/protocol_test.cpp:12:
tests/integration_tests/../../include/protocol.h:225:50: note:   initializing argument 2 of ‘int Protocol<NIC>::receive(Protocol<NIC>::Buffer*, Protocol<NIC>::Address*, void*, unsigned int) [with NIC = NIC<ProtocolTestEngine, ProcolTestEngine2>; Protocol<NIC>::Buffer = Buffer<Ethernet::Frame>]’ 
  225 | int Protocol<NIC>::receive(Buffer* buf, Address *from, void* data, unsigned int size) {
      |                                         ~~~~~~~~~^~~~
```

**Fix:**

```cpp
class ProcolTestEngine2 : public SharedMemoryEngine {
public:
    ProcolTestEngine2() : SharedMemoryEngine() {}
    virtual ~ProcolTestEngine2() = default;
};

// Define required trait specialization for our test
// Note: This must be a template specialization, not a namespace
template<> struct Traits<Protocol<NIC<ProtocolTestEngine, ProcolTestEngine2>>> : public Traits<void> {
    static const bool debugged = false;  // Turn off debugging for Protocol
    static const unsigned int ETHERNET_PROTOCOL_NUMBER = 0x1234;
};

```

```cpp
int bytes_received = proto2->receive(observer2->last_buffer, &src_addr, received_large.data(), received_large.size());
```

## Proposed Changes

### Component message type decision improved

Communicator refer to their owner's ComponentType to filter messages (Being a producer does not exclude the consumer behavior). Each component should have a type() method that is a getter for a ComponentType _type attribute.

```cpp
enum class ComponentType : std::uint8_t {
      GATEWAY,
      PRODUCER,
      CONSUMER, // New type for producer registration
      // ...
  };
```

```cpp
  void Communicator<Channel>::update(typename Channel::Observed* obs, typename Channel::Observer::Observing_Condition c, Buffer* buf) {
      // Skip filtering if no buffer or no owner component
      if (!buf || !_owner_component) {
          Observer::update(c, buf);
          return;
      }
      
      try {
          // Extract message header information
          std::uint8_t temp_header[16];
          _channel->peek(buf, temp_header, 16);
          
          // Extract message type and unit type
          unsigned int offset = 0;
          Message::Type msg_type = static_cast<Message::Type>(Message::extract_uint8t(temp_header, offset, 16));
          offset = 1 + 8; // Skip type and origin
          offset += 8;    // Skip timestamp
          DataTypeId unit_type = static_cast<DataTypeId>(Message::extract_uint32t(temp_header, offset, 16));
                    
          // Apply role-specific filtering
          bool should_deliver = false;

          switch (_owner_component->type())
          {
            case ComponentType::GATEWAY:
                // Gateway accepts all INTEREST and REG_PRODUCER messages
                should_deliver = (msg_type == Message::Type::INTEREST || msg_type == Message::Type::REG_PRODUCER);
                break;

            case ComponentType::PRODUCER:
              // Producer components care about INTEREST messages for their data type
              if (msg_type == Message::Type::INTEREST) {
                  DataTypeId produced_type = _owner_component->get_produced_data_type();
                  should_deliver = (unit_type == produced_type);
              }
            
            case ComponentType::CONSUMER:
                // Consumer components care about RESPONSE messages for their interests
                if (msg_type == Message::Type::RESPONSE) {
                    // Apply period-based filtering
                    auto now = std::chrono::high_resolution_clock::now();
                    auto now_us = std::chrono::duration_cast<std::chrono::microseconds>(
                        now.time_since_epoch()).count();
                    
                    for (auto& interest : _owner_component->_active_interests) {
                        if (interest.type == unit_type) {
                            if (now_us - interest.last_accepted_response_time_us >= interest.period_us) {
                                interest.last_accepted_response_time_us = now_us;
                                should_deliver = true;
                                break;
                            }
                        }
                    }
                }
         }
          
          // Handle delivery or discard
          if (should_deliver) {
              Observer::update(c, buf);
          } else {
              _channel->free(buf);
          }
      } catch (const std::exception& e) {
          // Fall back to regular update behavior on error
          Observer::update(c, buf);
      }
  }
```

### Communicator Implementation

**Issue:** Communicator header has a forward declaration of class Component. But it then calls methods of the component class using its _owner_compnent pointer. In order to fix this either the component declaration in the communicator header should actually be a template or the file should include component.h

```cpp
class Component;

template <typename Channel>
class Communicator: public Concurrent_Observer<typename Channel::Observer::Observed_Data, typename Channel::Observer::Observing_Condition>
{
    ...
};

...

is_consumer = !_owner_component->_active_interests.empty();
...
```

**Proposed Fixes:**

**Using a template:**
```cpp
template <typename Channel, typename Component>
class Communicator: public Concurrent_Observer<typename Channel::Observer::Observed_Data, typename Channel::Observer::Observing_Condition>
{
    ...
};

...

is_consumer = !_owner_component->_active_interests.empty();
...
```

**Including Compnent.h:**
```cpp
#include "component.h"

template <typename Channel>
class Communicator: public Concurrent_Observer<typename Channel::Observer::Observed_Data, typename Channel::Observer::Observing_Condition>
{
    ...
};

...

is_consumer = !_owner_component->_active_interests.empty();
...
```