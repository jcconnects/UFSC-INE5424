# P3 initial activities

## Overview

This document details the efforts applied to the implementation of P3.

## Changes

### 1. `Message` class (`include/message.h`)
- **New message implementation:** As previously stated, the message class is passed through a restoration, in order to meet the requirements established from P3 onwards. It is initially implemented with P3 in mind, but it can easily be extended to P5, where MAC codes will be included.
    - **Overview:** The idea is that only the Communicator can create messages. Therefore, all components will need to ask the communicator to create a message, which allows the parameters to be checked before the message is created. This, together with the private setters, makes the message constant throughout the sending and receiving flow.
    - **Attributes:**
        - ```cpp
                class Message {
                    ...

                    private:
                        /* Attributes */
                        Type _message_type;
                        Origin _origin;
                        std::uint64_t _timestamp;
                        std::uint32_t _type;
                        std::uint32_t _period;                 // INTEREST
                        std::vector<std::uint8_t> _value;      // RESPONSE
                        // std::vector<std::uint8_t> _mac;     // INTEREST and RESPONSE

                        // Serialized message buffer
                        std::vector<std::uint8_t> _serialized_data;
                };
          ```
        - Each message has a type assigned to it (for now, INTEREST or RESPONSE). The `_origin`, `_timestamp` and `_type` attributes are independent of the message type. Other attributes are configured according to the type passed in the constructor.
    - **Serialization:** Since the sending expects a `const void* data` and an `unsigned int size`, the message still needs to place all its contents inside a byte pointer for sending in the communication layer. For this, there is the `serialize()` method, which assembles the message as a byte array (`std::uint8_t`). When calling the data() method, the message automatically serializes its attributes, depending on its type, and returns the contents of the byte array. Some helper methods have been defined to help with serialization.
        - ``` cpp
                void Message::serialize() {
                    // Clear before any operations
                    _serialized_data.clear();

                    append_uint8t(static_cast<uint8_t>(_message_type)); // C++ can't handle bits
                    append_address(_origin);
                    append_uint64t(_timestamp);
                    append_uint32t(_type);

                    if (_message_type == Type::INTEREST)
                        append_uint32t(_period);
                    else if (_message_type == Type::RESPONSE)
                        append_vector(_value);
                }
          ```
    - **Deserialization:** Therefore, when a message is received, it will be a sequence of bytes, which needs to be deserialized, that is, transformed into an object of the `Message` class, for later operation of the application. The `deserialize()` method is responsible for this. Some helper methods for deserialization have also been defined.
        - ```cpp
                Message Message::deserialize(const void* serialized, const unsigned int size) {
                    const std::uint8_t* bytes = static_cast<const std::uint8_t*>(serialized);

                    Message msg;
                    unsigned int offset = 0;

                    msg.message_type(static_cast<Type>(extract_uint8t(bytes, offset, size)));
                    msg.origin(extract_address(bytes, offset, size));
                    msg.timestamp(extract_uint64t(bytes, offset, size));
                    msg.type(extract_uint32t(bytes, offset, size));

                    if (msg.message_type() == Type::INTEREST) {
                        msg.period(extract_uint32t(bytes, offset, size));
                    } else if (msg.message_type() == Type::RESPONSE) {
                        unsigned int value_len = size - offset;
                        if (value_len > 0) {
                            msg.value(bytes + offset, value_len);
                            offset += value_len;
                        } else {
                            msg.value(nullptr, 0);
                        }
                    }

                    msg.serialize();
                    return msg;
                }
          ```

### 2. `Protocol` class (`include/protocol.h`)
- **Broadcast handling:** Previously, when an external broadcast message was received, i.e. a message on port 0, the API simply discarded the message. From the application's point of view, a user may want someone to listen on port 0, precisely to deal with these cases of external broadcasts (such as a Gateway, for example). Therefore, the API must allow this element to be notified and the message to be properly handled. Considering this fact, the update method of the Protocol class was modified so that:
    - When a message is the result of an internal broadcast, that is, sended by a communicator with the same physical address as the message destination, all of them communicators observing protocol are notified.
    - When a message is the result of an external broadcast, only the communicator attached to port 0 will receive the message, and the application that uses it will be responsible for defining what will be done with the received message.
    - ``` cpp
            template <typename NIC>
            void Protocol<NIC>::update(typename NIC::Protocol_Number prot, Buffer * buf) {
                db<Protocol>(TRC) << "Protocol<NIC>::update() called!\n";
                
                // Extracting MAC Addresses to compare
                Physical_Address src_mac = buf->data()->src;
                Physical_Address my_mac = _nic->address();

                // Extracting packet from frame payload
                Packet* packet = reinterpret_cast<Packet*>(buf->data()->payload);
                
                // Extracting dst port from packet header
                Port dst_port = packet->header()->to_port();

                if (dst_port == 0) {
                    db<Protocol>(INF) << "[Protocol] Received broadcast packet.\n";
                } else {
                    db<Protocol>(INF) << "[Protocol] Received packet for port " << dst_port << "\n";
                }

                // Internal Broadcast
                if (src_mac == my_mac && dst_port == 0) {
                    if (!Protocol::_observed.notifyAll(buf)) { // Notify all observers
                        db<Protocol>(INF) << "[Protocol] broadcast data received, but no one was notified.\n";
                        _nic->free(buf);
                    }
                } else {
                    if (!Protocol::_observed.notify(dst_port, buf)) { // Use port for notification
                        db<Protocol>(INF) << "[Protocol] data received, but no one was notified for port " << dst_port << ". Freeing buffer.\n";
                        // No observers for this specific port (and not broadcast, or broadcast had no observers)
                        _nic->free(buf);
                    }
                }
            }
      ```
- **Port definition type:** Changed to `std::uint16_t`, as it covers the entire scope normally used by applications (0 to 65535).
    - ```cpp
            typedef std::uint16_t Port;
      ```

### 3. `Conditionally_Data_Observed` class (`include/observed.h`)
- **Notification of all observers:** Added a method to notify all observers regardless of condition.
    - ```cpp
            template <typename T, typename C>
            bool Conditionally_Data_Observed<T, C>::notifyAll(T* d) {
                bool notified = false;

                for (typename Observers::Iterator obs = _observers.begin(); obs != _observers.end(); ++obs) {
                    (*obs)->update(obs->rank(), d);
                    notified = true;
                }

                return notified;
            }
      ```

### 4. `Communicator` class (`include/communicator.h`)
- **Message creation:** Updated to use the new version of the Message class. Parameter verification is still required to ensure message integrity even before creation.
    - ```cpp
            template <typename Channel>
            Message Communicator<Channel>::new_message(Message::Type message_type, std::uint32_t type, unsigned int period, const void* value_data, const unsigned int value_size) {
                switch (message_type)
                {
                    case Message::Type::INTEREST:
                        return Message(message_type, _address, type, period=period);
                        break;
                    case Message::Type::RESPONSE:
                        return Message(message_type, _address, type, value_data=value_data, value_size=value_size);
                    default:
                        return Message();
                        break;
                }
            }
      ```

## Observations:
- All components need to be updated to first use the new definition of the `Message` class and then work as expected for communication in P3.
- The logic of the communication API must be ok, since it is the application's responsibility to create periodic threads to respond and maintain interested parties.
- The `Message` class was not properly tested