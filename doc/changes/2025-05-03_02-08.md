# P2 refactoring accordingly to teacher's advice and group's discussions

## Overview

The objective of this refactoring is to address the issues raised by the professor in the evaluation of P2, in line with the group's verdict, and to simplify certain code segments and implemented logics, aiming for better object-oriented practices and improved alignment with future projects.

## Changes

### 1. `SocketEngine` class (`include/socketEngine.h`)
- **Restored epoll implementation:** The previous version of the SocketEngine was restored for external communication, moving all epoll logic back to this class instead of keeping it within the NIC.
- **Receive method:** A `receive` method was added to serve as the new signal handler. The goal is to make the class fully responsible for all socket-related operations, in accordance with the Single Responsibility Principle from SOLID. Within this method, a call is made to `handleExternal`, which should be specialized by the NIC class. Its sole purpose is to allocate a buffer for the received frame and notify the observers.
    - ```cpp
        void SocketEngine::receive() {
            db<SocketEngine>(TRC) << "SocketEngine::receive() called!\n";

            // Checks weather engine is still active
            if (!running()) {
                db<SocketEngine>(WRN) << "[SocketEngine] receive() called when engine is inactive\n";
                return;
            }

            Ethernet::Frame frame;
            struct sockaddr_ll src_addr;
            socklen_t addr_len = sizeof(src_addr);
            
            int bytes_received = recvfrom(this->_sock_fd, &frame, sizeof(frame), 0, reinterpret_cast<sockaddr*>(&src_addr), &addr_len);
            
            // Checks weather receive was sucessful
            if (bytes_received < 0) {
                db<SocketEngine>(INF) << "[SocketEngine] no data received\n";
                if (errno != EAGAIN && errno != EWOULDBLOCK) {
                    perror("recvfrom");
                }
                return;
            }

            // Checks for valid Ethernet frame size (at least header size)
            if (static_cast<unsigned int>(bytes_received) < Ethernet::HEADER_SIZE) {
                db<SocketEngine>(ERR) << "[SocketExternalEngine] Received undersized frame (" << bytes_received << " bytes)\n";
                return;
            }
            
            // Convert protocol from network to host byte order
            frame.prot = ntohs(frame.prot);
            db<SocketEngine>(INF) << "[SocketEngine] received frame: {src = " << Ethernet::mac_to_string(frame.src) << ", dst = " << Ethernet::mac_to_string(frame.dst) << ", prot = " << frame.prot << ", size = " << bytes_received << "}\n";

            this->handleExternal(&frame, static_cast<unsigned int>(bytes_received));
        }
      ```

### 2. `SharedMemoryEngine` class (`include/sharedMemoryEngine.h`)
- **Updated send method:** The previously unused `send` method has been updated to invoke `handleInternal`, which — similarly to the method in `SocketEngine` — should be implemented in the NIC class. Its purpose is to forward the allocated buffer by notifing the observers.
    - ```cpp
            int SharedMemoryEngine::send(Buffer<Ethernet::Frame>* buf) {
                db<SharedMemoryEngine>(TRC) << "SharedMemoryEngine::send() called!\n";

                this->handleInternal(buf);

                return buf->size();
            }
      ```

### 3. `NIC<ExternalEngine, InternalEngine>` class (`include/nic.h`)
- **Restored P1 base implementation:** Several changes were made due to a misinterpretation of the P2 instructions. Therefore, the approach was to revert to the version used in P1 and apply only the minimally necessary modifications for implementing P2. Overall, the logic remains the same, but the code is now cleaner and easier to understand.
- **Buffer release on sending:** This responsibility previously belonged to the protocol. However, for internal communication, the buffer should not be released. Reusing the same buffer when notifying observers reduces the time spent on decapsulation and re-encapsulation. Therefore, the responsibility for releasing the buffer after a transmission via the external engine was assigned to the NIC.
- **Buffer allocation:** NIC now adds `Ethernet::HEADER_SIZE` to size passed as parameter. That means that `NIC::alloc` expects `size` to be the packet size, and not the full frame size.

### 4. `Protocol<NIC>` class (`include/protocol.h`)
- **Fixed broadcast address port as 0:** The port of the logical broadcast address previously received a NULL_VALUE, which was already zero, but this was implicit due to the enum. This assignment is now explicitly stated in the code.
    - ``` cpp
        template <typename NIC>
        const typename Protocol<NIC>::Address Protocol<NIC>::Address::BROADCAST = 
            typename Protocol<NIC>::Address(
                Ethernet::BROADCAST, // MAC broadcast
                0 // Broadcast port
            );
      ```
- **Minor changes:**
    - Fixed `Packed::data()` to return reinterpreted `_data` instead of `&_data`
    - Removed unecessary (mostly redundant) code blocks

### 5. `Communicator<Channel>` class (`include/communicator.h`)
- **Nested Message class:** This idea emerged during the current refactoring and makes perfect sense within the context of P2, but it will be revised in the implementation of P3. Essentially, since only the components and the communicator use objects of the Message class, the decision was made to nest it within the Communicator class, centralizing message creation and size control there. In the future, we will have at least four types of messages. Therefore, a modification is planned to allow each message type to be specialized with a different payload type. As such, this change is temporary.
    - ``` cpp
        template <typename Channel>
        class Communicator: public Concurrent_Observer<typename Channel::Observer::Observed_Data, typename Channel::Observer::Observing_Condition>
        {
            
            public:
                ...
                
                static constexpr const unsigned int MAX_MESSAGE_SIZE = Channel::MTU; // Maximum message size in bytes
                
                class Message {
                    friend class Communicator<Channel>;

                    private:
                        // Constructors
                        Message(const void* data, unsigned int size, const Address& origin);
                        
                    public:
                        Message();
                        ~Message() = default;
                    
                        // Getters
                        const void* data() const; // Returns const void* for generic access
                        const unsigned int size() const;
                        
                        // Setters
                        void setData(const void* data, unsigned int size);

                        // Origin Address getter/setter
                        const Address& origin() const;
                        void origin(const Address& addr);

                    private:
                        std::uint8_t _data[MAX_MESSAGE_SIZE];
                        unsigned int _size;
                        Address _origin;
                };

                ...
        }
      ```
- **Method for message creation:** Additionally, a method was introduced to enable controlled message creation with size validation against the maximum allowed size, aiming to avoid repeated checks in different parts of the code, as well as checks on the data pointer. Once again, since the entire Message class implementation will be revisited, this solution is likely to be modified in the future.
    - ```cpp
        template <typename Channel>
        typename Communicator<Channel>::Message* Communicator<Channel>::new_message(const void* data, unsigned int size) {
            if (size > MAX_MESSAGE_SIZE) {
                db<Communicator>(WRN) << "[Communicator] attempted creating message with oversize.\n";
                return nullptr;
            }

            if (size == 0) {
                return new Message();
            }

            if (data == nullptr) {
                db<Communicator>(WRN) << "[Communicator] attempted creating message with null data.\n";
                return nullptr;
            }

            return new Message(data, size, _address);
        }
      ```

### 6. `Initializer` class (`include/initializer.h`)
- **Refactor to only create NIC and Protocol:** Considering that the goal of the project is to implement a library for communication between autonomous systems, the class responsible for initializing the `NIC` and the `Protocol` must be independent of the application being executed. In our project, which uses a basic implementation of autonomous vehicles as a test application, it does not make sense for the initialization class to create vehicles and their components. Therefore, this class now serves solely to instantiate a NIC and a Protocol, and it is designed to work with any type of application.
    - ```cpp
        class Initializer {

            public:
                typedef NIC<SocketEngine, SharedMemoryEngine> NIC_T;
                typedef Protocol<NIC_T> Protocol_T;


                Initializer() = default;
                ~Initializer() = default;

                /**
                * @brief Creates a network interface abstraction.
                * 
                * @return The created NIC
                */
                static NIC_T* create_nic();

                /**
                * @brief Creates a protocol for system communication
                * @param nic a previously created network interface
                * 
                * @return The created Protocol, associated with the network interface passed as a parameter
                */
                static Protocol_T* create_protocol(NIC_T* nic);
        };
      ```

### 7. `Vehicle` class (`include/vehicle.h`)
- **Constructor:**  The `Vehicle` class is now responsible for creating its own NIC and Protocol, as well as configuring its own MAC address based on a given ID. It utilizes the `Initializer` class for this purpose, as previously mentioned.
    - ``` cpp
            Vehicle::Vehicle(unsigned int id) : _id(id), _running(false)
            {
                db<Vehicle>(TRC) << "Vehicle::Vehicle() called!\n";

                // Setting vehicle NIC
                _nic = Initializer::create_nic();
                
                // Setting NIC address
                Address addr; // We don't set the address here anymore;
                addr.bytes[0] = 0x02; // the NIC gets its address from the SocketEngine.
                addr.bytes[1] = 0x00;
                addr.bytes[2] = 0x00;
                addr.bytes[3] = 0x00;
                addr.bytes[4] = (id >> 8) & 0xFF;
                addr.bytes[5] = id & 0xFF;
                _nic->setAddress(addr);
                
                // Setting vehicle protocol
                _protocol = Initializer::create_protocol(_nic);
                
                db<Vehicle>(INF) << "[Vehicle " << _id << "] created with address: " << VehicleNIC::mac_to_string(address()) << "\n";
            }
      ```
- **Stopping execution:** The new shutdown sequence for a vehicle is as follows:
    - Stop the NIC and its engines
    - Stop the components
    - ```cpp
        void Vehicle::stop() {
            db<Vehicle>(TRC) << "Vehicle::stop() called for ID " << _id << "!\n";

            if (!running()) {
                db<Vehicle>(WRN) << "[Vehicle " << _id << "] stop() called but not running.\n";
                return;
            }

            // First stop NIC and its engines
            _nic->stop();

            // Then stops each component
            db<Vehicle>(INF) << "[Vehicle " << _id << "] Stopping components...\n";
            stop_components();

            _running.store(false, std::memory_order_release); // Mark vehicle as stopped
            db<Vehicle>(INF) << "[Vehicle " << _id << "] stopped.\n";
        }
      ```
- **Components creation and management:** The vehicle is now responsible for creating and managing its own components. The component creation method, which was previously in the `Initializer` class, has been moved into the `Vehicle` class, which now handles the instantiation of its components as needed.
    - ``` cpp
        template <typename ComponentType, typename... Args>
        void Vehicle::create_component(const std::string& name, Args&&... args) {
            _components.push_back(std::make_unique<ComponentType>(this, id(), name, protocol(), std::forward<Args>(args)...));   
        }
      ```
- **Ports:** In order to create the components with the right address, `Vehicle`class now stores an enum class, which defines one fixed port for each component. This is extensible.
    - ```cpp
        // Defining component ports
        enum class Ports {
            BROADCAST,
            ECU1,
            ECU2,
            BATTERY,
            INS,
            LIDAR,
            CAMERA
        };
      ```
- **Getters:** Some getters were added to the `Vehicle` class to allow access to key information, including the vehicle's ID, physical address, associated protocol, and current execution state.
    - ``` cpp
        const unsigned int Vehicle::id() const {
            return _id;
        }

        const bool Vehicle::running() const {
            return _running.load(std::memory_order_acquire);
        }

        Vehicle::VehicleProt* Vehicle::protocol() const {
            return _protocol;
        }

        const Vehicle::Address Vehicle::address() const {
            return _nic->address();
        }
      ```

### 8. `Component` class (`include/component.h`)
- **Definition and constructor:** removed some unecessary attributes, like `_protocol` (vehicle should be the only one with the reference to it) and `_address` (communicator already stores the address). Also added a new attribute called `_log_dir`. The goal is to set a fixed directory where the component exports its log file, based on the vehicle's ID. Additionally, the file name is now also indexed using the vehicle ID.
    - ``` cpp
        Component::Component(Vehicle* vehicle,  const unsigned int vehicle_id, const std::string& name) : _vehicle(vehicle), _name(name), _running(false), _thread(0) {
            if (!_vehicle) {
                throw std::invalid_argument("Component requires a non-null vehicle instance.");
            }

            // Communicator will be created in each specific component Constructor, due to port setting";

            // Setting log filename
            _filename = _name + std::to_string(vehicle_id) + "_log.csv";

            // Setting log dir
            _log_dir = "./logs/vehicle_" + std::to_string(vehicle_id) + "/"; 
        }
      ```
- **Stop sequence:** Logic was modified to first close the communication, and then terminate its threads.
    - ``` cpp
        void Component::stop() {
            db<Component>(TRC) << "Component::stop() called for component " << getName() << "\n";

            if (!running()) {
                db<Component>(WRN) << "[Component] stop() called for component " << getName() << " when it is already stopped.\n";
                return;
            }

            // Fisrt set its own running state
            _running.store(false, std::memory_order_release);
            
            // Then stops communicator, releasing any blocked threads
            _communicator->close();
            db<Component>(INF) << "[Component] Communicator closed for component" << getName() << ".\n";
            
            // Then join thread
            if (_thread != 0) {
                int join_rc = pthread_join(_thread, nullptr);

                if (join_rc == 0) {
                        db<Component>(INF) << "[Component] thread joined for component " << getName() << ".\n";
                } else {
                        db<Component>(ERR) << "[Component] failed to join thread for component " << getName() << "! Error code: " << join_rc << "\n";
                        // Consider logging errno or using strerror(join_rc) if applicable
                }

                _thread = 0; // Reset thread handle after join
            }

            close_log_file(); // Close log file after stopping
            db<Component>(INF) << "[Component] " << getName() <<" stopped.\n";
        }
      ```
- **Other changes:** mostly fixes on debug messages, but also removed some unecessary verifications

### 9. Specific Components
- **Constructor:** Each specific component is now responsible for creating its own communicator, with it's own address, composed by vehicle MAC address and component port, defined by `Vehicle` class.
- **General:** separated method implementation from class definition.

### 10. Traits
- Defined one traits for each component class. This allows debbuging each component separately.

### 11. General Changes
- Fixed circular dependencies cases, and simplified includes on most classes. With that, `types.h` and `address.h` are no longer necessary. We can define by `typedef` or `using` (this should be standard, as it does not create extra unecessary dependencies)

### 12. `demo.cpp`
- Using `std::filesystem` to create logs directories, also indexed by vehicle's id. This makes easier to understand debug files.
- Fixed to use new implementation of `Vehicle` class.

## Observations
- While debugging, I noticed that messages are not arriving completely at the components. Most likely, there is an unnecessary size reduction in the receiving logic that requires further investigation.
- I'm not certain, but it seemed that not all internal messages are being sent correctly. I'm unsure whether the issue lies in the component logic or in the communication API. This also requires verification.