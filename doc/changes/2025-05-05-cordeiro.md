---
title: "Message Handling and Logging Improvements"
date: 2025-05-05
---

# Message Handling and Logging Improvements

## Overview

This update enhances message handling and component logging in the vehicle communication system. The changes provide a more robust approach to message creation, processing, and logging, with improved error handling and directory structure management. Several key components were modified to use consistent message handling patterns.

## Key Changes

### 1. Improved Message Interface

#### Message Size and Data Access

- Changed `data()` and `size()` methods to be `const`-qualified, ensuring they can be called on const Message objects
- Added proper `const_cast` in the serialization process of const methods to preserve logical constness
- Ensured consistent naming by renaming `type()` to `unit_type()` to better reflect its purpose

```cpp
// include/message.h
const void* Message::data() const {
    // Ensures message is serialized
    const_cast<Message*>(this)->serialize();

    // Returns serialized message
    return static_cast<const void*>(_serialized_data.data());
}

const unsigned int Message::size() const {
    // Ensure message is serialized
    const_cast<Message*>(this)->serialize();

    // Returns serialized message size
    return static_cast<const unsigned int>(_serialized_data.size());
}
```

#### Message Origin Handling

- Simplified message origin setting in the communicator with cleaner code
- Improved logging for address origins

```cpp
// Sets message origin address
message->origin(from);
db<Communicator>(INF) << "[Communicator] Received message origin set to: " << from << "\n";
```

### 2. Component Class Enhancements

#### Message Type Definition Cleanup

- Removed redundant typedef for Message in Component class to avoid inconsistencies

#### Improved Log Directory Management

- Added a robust approach for creating and managing log directories, with fallback options
- Added support for Docker container log directories
- Implemented better error handling for log directory creation

```cpp
std::string Component::initialize_log_directory(unsigned int vehicle_id) {
    std::string log_dir;
    
    // First try the Docker container's logs directory
    if (std::filesystem::exists("/app/logs")) {
        log_dir = "/app/logs/vehicle_" + std::to_string(vehicle_id) + "/";
    } else {
        // Try to use tests/logs directory instead of current directory
        if (!std::filesystem::exists("tests/logs")) {
            try {
                std::filesystem::create_directories("tests/logs");
            } catch (...) {
                // Ignore errors, will fall back if needed
            }
        }
        
        if (std::filesystem::exists("tests/logs")) {
            log_dir = "tests/logs/vehicle_" + std::to_string(vehicle_id) + "/";
        } else {
            // Last resort fallback to current directory
            log_dir = "./";
        }
    }
    
    // Create the directory if it doesn't exist
    if (log_dir != "./") {
        try {
            std::filesystem::create_directories(log_dir);
        } catch (...) {
            // If we can't create the directory, fall back to current directory
            log_dir = "./";
        }
    }
    
    return log_dir;
}
```

#### Enhanced Message Handling in Component Class

- Updated `send()` method to use the Communicator's message creation pattern properly
- Eliminated memory leaks by removing manual message memory management
- Updated `receive()` method to handle both RESPONSE message types and raw data properly
- Added better error handling and logging during message processing

```cpp
int Component::send(const void* data, unsigned int size, Address destination) {
    // Create response message with the data
    Message msg = _communicator->new_message(
        Message::Type::RESPONSE,  // Using RESPONSE type for raw data
        0,                        // Default type
        0,                        // No period for responses
        data,                     // The data to send
        size                      // Size of the data
    );
    
    // Send the message
    if (_communicator->send(msg, destination)) {
        db<Component>(INF) << "[Component] " << getName() << " sent " << size << " bytes to " << destination.to_string() << ".\n";
        return size; // Return bytes sent on success
    } else {
        db<Component>(ERR) << "[Component] " << getName() << " failed to send message.\n";
        return 0; // Indicate error
    }
}
```

### 3. ECU Component Improvements

#### Message Processing

- Completely refactored message handling to use the Message class directly
- Split message processing into separate methods for better organization
- Added specialized handlers for INTEREST and RESPONSE message types
- Improved logging with better message details

```cpp
void ECUComponent::process_message(const Message& message, const std::chrono::microseconds& recv_time) {
    // Extract message details
    auto message_type = message.message_type();
    auto origin = message.origin();
    auto timestamp = message.timestamp();
    auto type_id = message.unit_type();
    
    // Calculate latency
    auto latency_us = recv_time.count() - timestamp;
    
    // Log basic message information
    db<ECUComponent>(TRC) << "[ECUComponent] " << Component::getName() 
                         << " received message: type=" << (message_type == Message::Type::INTEREST ? "INTEREST" : "RESPONSE")
                         << ", from=" << origin.to_string()
                         << ", type_id=" << type_id
                         << ", latency=" << latency_us << "us\n";
    
    // Process based on message type
    std::string message_details;
    if (message_type == Message::Type::INTEREST) {
        process_interest_message(message, message_details);
    } else if (message_type == Message::Type::RESPONSE) {
        process_response_message(message, message_details);
    }
    
    // Log the message to CSV
    log_message(message, recv_time, std::chrono::microseconds(timestamp), message_details);
}
```

#### Improved Error Handling in Logging

- Added try-catch blocks for file operations
- Implemented fallback logging to console when file operations fail

### 4. Gateway Component Enhancements

#### Better Structure and Organization

- Added proper header guards to ensure the file is included only once
- Removed empty destructor implementation in favor of default
- Added a dedicated message processing method for better organization

```cpp
void GatewayComponent::process_message(const Message& message, 
                                      const std::chrono::microseconds& recv_time) {
    // Log message reception
    db<GatewayComponent>(INF) << "[GatewayComponent] Received message from " 
                             << message.origin().to_string() << "\n";
    
    // Log to CSV if file is open
    if (_log_file.is_open()) {
        try {
            _log_file << recv_time.count() << ","
                     << message.origin().to_string() << ","
                     << "unknown" << ","  // component type
                     << "unknown" << ","  // source vehicle
                     << message.unit_type() << ","
                     << "receive" << ","
                     << message.timestamp() << ","
                     << (recv_time.count() - message.timestamp()) << ","
                     << "raw_message_placeholder" << "\n";
            _log_file.flush();
        } catch (const std::exception& e) {
            db<GatewayComponent>(ERR) << "[GatewayComponent] error writing to log file: " 
                                     << e.what() << "\n";
        }
    }
}
```

### 5. Observer Fix

Fixed a critical bug in the `Conditionally_Data_Observed` class where observer ranking was incorrectly accessed using a dereferencing error:

```cpp
// Before
(*obs)->update(obs->rank(), d);

// After - Fixed
(*obs)->update((*obs)->rank(), d);
```

### 6. System Tests Improvements

- Modernized the demo application with better error handling
- Added more robust log directory management
- Improved child process status reporting
- Enhanced error reporting and process cleanup

## Benefits

1. **Improved Logging**: Better organization, error handling, and cross-platform support.
2. **Better Error Handling**: Added try-catch blocks and proper error reporting throughout the codebase.
3. **Fixed Observer Bug**: Corrected a potentially serious issue in the observer pattern implementation.

## Future Work

1. **Architecture**: Define how the gateway is going to be implemented.
2. **Pattern Definition**: Define and adjust which component is going to handle the response and the interest messages.
3. **Message Format Standardization**: Further standardize message formats across all components.
4. **Testing**: Add dedicated tests.