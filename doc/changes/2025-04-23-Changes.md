---
title: "Per-Component Communicator Architecture"
date: 2025-04-23
---

# Per-Component Communicator Architecture

## Overview
This update refactors the Vehicle-Component architecture to give each Component (thread) its own dedicated Communicator instance, rather than having a single Communicator within a Vehicle (process). This change allows for better isolation between components and more flexible communication patterns.

## Changes

### Component Class
- Added a Communicator member variable to each Component
- Added templated constructor to accept a Protocol and Address
- Added send/receive methods that delegate to the Component's Communicator
- Components are now responsible for their own network communication

#### Before:
```cpp
class Component {
    public:
        Component(Vehicle* vehicle, const std::string& name);
        // ...
    protected:
        Vehicle* _vehicle;
        std::string _name;
        // No communication mechanism in Component
        // ...
};
```

#### After:
```cpp
class Component {
    public:
        template <typename Protocol>
        Component(Vehicle* vehicle, const std::string& name, Protocol* protocol, typename Protocol::Address address);
        
        // New methods for communication
        template <typename Protocol>
        int send(const void* data, unsigned int size);
        
        template <typename Protocol>
        int receive(void* data, unsigned int size);
        
    protected:
        Vehicle* _vehicle;
        std::string _name;
        // New members for communication
        void* _communicator; // Use void* to handle any protocol type
        bool _has_communicator;
        // ...
};
```

### Vehicle Class
- Removed the single vehicle-level Communicator
- Removed send/receive methods (this functionality now belongs to components)
- Added protocol() accessor method to expose the protocol to components
- Added next_component_address() method to generate unique addresses for components
- Vehicle now acts as an address manager for its components

#### Before:
```cpp
class Vehicle {
    public:
        // ...
        int send(const void* data, unsigned int size);
        int receive(void* data, unsigned int size);
        
    private:
        // ...
        Communicator<Protocol<NIC<SocketEngine>>>* _comms;
        // ...
};

// Implementation
int Vehicle::send(const void* data, unsigned int size) {
    Message<MAX_MESSAGE_SIZE> msg = Message<MAX_MESSAGE_SIZE>(data, size);
    
    if (!_comms->send(&msg)) {
        // Error handling
        return 0;
    }
    
    return 1;
}

int Vehicle::receive(void* data, unsigned int size) {
    // ... implementation details ...
    Message<MAX_MESSAGE_SIZE> msg = Message<MAX_MESSAGE_SIZE>();
    if (!_comms->receive(&msg)) {
        // Error handling
        return 0;
    }
    
    // ... copy data to buffer ...
    return msg.size();
}
```

#### After:
```cpp
class Vehicle {
    public:
        // ...
        // Removed send/receive methods
        
        // New methods for component communication setup
        Protocol<NIC<SocketEngine>>* protocol() const { return _protocol; }
        typename Protocol<NIC<SocketEngine>>::Address next_component_address();
        
    private:
        // ...
        // Removed Communicator
        // New address management members
        typename Protocol<NIC<SocketEngine>>::Address _base_address;
        unsigned int _next_component_id;
        // ...
};

// New address generation implementation
typename Protocol<NIC<SocketEngine>>::Address Vehicle::next_component_address() {
    typename Protocol<NIC<SocketEngine>>::Address addr = _base_address;
    addr.port(_next_component_id++);
    return addr;
}
```

### Initializer Class
- Added a create_component template method for creating components with their own communicators
- The method:
  - Gets the protocol from the vehicle
  - Gets a unique address for the component
  - Creates the component with protocol and address
  - Adds the component to the vehicle

```cpp
template <typename ComponentType, typename... Args>
static ComponentType* create_component(Vehicle* vehicle, const std::string& name, Args&&... args) {
    if (!vehicle) {
        return nullptr;
    }
    
    // Get the protocol from the vehicle
    auto* protocol = vehicle->protocol();
    
    // Get the next available address for this component
    auto address = vehicle->next_component_address();
    
    // Create the component with the protocol and address
    ComponentType* component = new ComponentType(vehicle, name, protocol, address, std::forward<Args>(args)...);
    
    // Add the component to the vehicle
    vehicle->add_component(component);
    
    return component;
}
```

### Component Implementations
- Updated SenderComponent and ReceiverComponent to use the new architecture
- Modified constructors to accept Protocol and Address parameters
- Changed send/receive calls to use their own communicator instead of the vehicle's

#### Before (SenderComponent example):
```cpp
void* SenderComponent::run(void* arg) {
    // ...
    std::string msg = "Vehicle " + std::to_string(c->vehicle()->id()) + " message " + std::to_string(counter);
    
    // Using vehicle's send method
    if (c->vehicle()->send(msg.c_str(), msg.size())) {
        // Message sent
    }
    // ...
}
```

#### After (SenderComponent example):
```cpp
void* SenderComponent::run(void* arg) {
    // ...
    std::string msg = "Vehicle " + std::to_string(c->vehicle()->id()) + " message " + std::to_string(counter);
    
    // Using component's own send method
    if (c->template send<Protocol<NIC<SocketEngine>>>(msg.c_str(), msg.size())) {
        // Message sent
    }
    // ...
}
```

### Demo Application
- Updated to use Initializer::create_component instead of directly creating components

#### Before:
```cpp
// Create components based on vehicle ID
if (v->id() % 2 == 0) {
    db<Vehicle>(INF) << "[Vehicle " << v->id() << "] creating sender component\n";
    v->add_component(new SenderComponent(v));
}

db<Vehicle>(INF) << "[Vehicle " << v->id() << "] creating receiver component\n";
v->add_component(new ReceiverComponent(v));
```

#### After:
```cpp
// Create components based on vehicle ID
if (v->id() % 2 == 0) {
    db<Vehicle>(INF) << "[Vehicle " << v->id() << "] creating sender component\n";
    // Use the new Initializer::create_component method
    Initializer::create_component<SenderComponent>(v, "Sender");
}

db<Vehicle>(INF) << "[Vehicle " << v->id() << "] creating receiver component\n";
// Use the new Initializer::create_component method
Initializer::create_component<ReceiverComponent>(v, "Receiver");
```

## Benefits
- Better separation of concerns: components handle their own communication
- Improved isolation between components
- More flexible communication patterns possible
- Potential for direct component-to-component communication without vehicle involvement
- Easier to add different types of components with varying communication needs
