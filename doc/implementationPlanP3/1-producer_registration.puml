@startuml Producer Registration Flow

title Producer Registration with Gateway

participant Vehicle as Veh
participant ProducerComponent as PComp
participant PComp_Comm as PComm <<Communicator>>
participant GatewayComponent as GComp
participant GComp_Dispatcher as GDisp <<Thread>>
participant GComp_Comm as GComm <<Communicator>>
participant ProtocolLayer as Proto
participant NICLayer as NIC

== Producer Registers with Gateway (on Startup) ==
Veh -> PComp : Start Component
PComp -> PComm : "new_message(REG_PRODUCER, PComp._produced_data_type)"
note right: PComm._address is PComp's address (MAC_VEHICLE:Port_Producer)\nunit_type field of msg carries the DataTypeId produced.
PComm -> PComm : Create "reg_msg"
PComp -> PComm : "send(reg_msg, MAC_VEHICLE:Port_Gateway_0)"
note right: Target is Gateway's known port (0) on own vehicle.
PComm -> Proto : "send(PComp_Addr, MAC_VEHICLE:0, reg_payload, size)"
Proto -> NIC : "send(eth_frame_reg)" (if MAC_VEHICLE != self, else internal)

NIC -> Proto : (Gateway's Protocol) "update(PROTO_ID, eth_frame_reg_buf)"
Proto -> GComm : "update(Port 0, eth_frame_reg_buf)"
GComm -> GComm : Deserialize "reg_msg_obj" from buffer.\nFilter: "msg_type == REG_PRODUCER".
GComm -> GDisp : Queue "eth_frame_reg_buf" by calling "Observer::update(c,buf)".

GDisp -> GComm : "receive(reg_msg_obj_final)"
GDisp -> GDisp : Identify message type: REG_PRODUCER
GDisp -> GComp : Directly call "handle_reg_producer(reg_msg_obj_final)"
GComp -> GComp : Process registration:\n"_producer_registry[reg_msg_obj_final.unit_type()].push_back(reg_msg_obj_final.origin().port())"
note right GComp: Stores mapping: "DataTypeId_Produced -> Port_Producer"

@enduml 