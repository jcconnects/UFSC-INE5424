This document presents the proposed design pattern for the Operating Systems II course in the first semester of 2025. The proposal revolves around the development of a reliable and secure communication library for critical autonomous systems, set in the scenario of autonomous vehicles.

Among the global project requirements, we have:



Development must be done in the C++ programming language using only the C Standard Library (libc) and the C++ Standard Library on a native POSIX platform.

Each autonomous system (e.g., vehicle) must be modeled as a macro-object that has a specific POSIX process associated with it (and not a specific VM or SBC).

Each component of each autonomous system (e.g., sensor, fusion, ML model) must be modeled as a macro-object that has a POSIX thread associated with it (and not a process).

Network communication will always be via broadcast, with a range limited by the inherent collision domain of the respective technology (a 5G radio cell or an Ethernet local network).

Groups will consist of up to 4 students and may include students from both classes, provided they are present at all project progress presentations and also at the final presentation.

After developing and testing each stage of the project, groups will submit, via Moodle, a link to a specific commit in their own Git repository, with all specifications and project diagrams located in a folder called "doc". Along with the link, send the access credentials so that the evaluators can access your code (do not use an open repository; you can use https://codigos.ufsc.br/). At the root of your development tree, include a Makefile that is capable of triggering the compilation and execution of all tests simply with the command make. The slides used in the progress presentations of each stage of the project can either be in the same "doc" folder in Git or in an online document referenced by the second URL of the assignment in Moodle. Presentations must contain a simple performance evaluation with average latency observed during testing.



1. Communication Between Systems and Their Components

The communication library must present a unified API for all agents, regardless of whether they are autonomous systems or components thereof. The messages exchanged between agents have a known maximum size and are smaller than the network's MTU, therefore they will never be fragmented.

Propagation of Asynchronous Events

The asynchronous events of the communication protocol stack being developed in this project should be treated under the prism of the Observer X Observed design pattern, with the observed entities notifying their observers to update their states. In particular, the reception of messages must always be asynchronous, without rendezvous protocols.

Engine for Communication Between Autonomous Systems

The Engine class from the specification above must be implemented using raw sockets with Ethernet frames. Programming languages with a level of abstraction of the computational platform no higher than this can be considered.

Messages

At this stage, messages are a simple array of bytes:

M = {.*}

API

Both autonomous systems and their components will communicate through the same set of basic primitives, respecting the same API



// Fundamentals for Observer X Observed

template 

class Conditional_Data_Observer;

template 

class Conditionally_Data_Observed;

// Conditional Observer x Conditionally Observed with Data decoupled by a Semaphore

template

class Concurrent_Observer;

template

class Concurrent_Observed

{

 friend class Concurrent_Observer;

public:

 typedef D Observed_Data;

 typedef C Observing_Condition;

 typedef Ordered_List, C> Observers;

public:

 Concurrent_Observed() {}

 ~Concurrent_Observed() {}

 void attach(Concurrent_Observer * o, C c) {

 _observers.insert(o);

 }

 void detach(Concurrent_Observer * o, C c) {

 _observers.remove(o);

 }

 bool notify(C c, D * d) {

 bool notified = false;

 for(Observers::Iterator obs = _observers.begin(); obs != _observers.end(); obs++) {

 if(obs->rank() == c) {

 obs->update(c, d);

 notified = true;

 }

 }

 return notified;

 }

private:

 Observers _observers;

};

template

class Concurrent_Observer

{

 friend class Concurrent_Observed;

public:

 typedef D Observed_Data;

 typedef C Observing_Condition;

public:

 Concurrent_Observer(): _semaphore(0) {}

 ~Concurrent_Observer() {}

 void update(C c, D * d) {

 _data.insert(d);

 _semaphore.v();

 }

 D * updated() {

 _semaphore.p();

 return _data.remove();

 }

private:

 Semaphore _semaphore;

 List _data;

};

// Network

class Ethernet; // all necessary definitions and formats

template 

class NIC: public Ethernet, public Conditional_Data_Observed,

Ethernet::Protocol>, private Engine

{

public:

 static const unsigned int BUFFER_SIZE =

Traits::SEND_BUFFERS * sizeof(Buffer) +

Traits::RECEIVE_BUFFERS * sizeof(Buffer);

 typedef Ethernet::Address Address;

 typedef Ethernet::Protocol Protocol_Number;

 typedef Buffer Buffer;

 typedef Conditional_Data_Observer, Ethernet::Protocol> Observer;

 typedef Conditionally_Data_Observed, Ethernet::Protocol> Observed;

protected:

 NIC();

public:

 ~NIC();

 int send(Address dst, Protocol_Number prot, const void * data, unsigned int size);

 int receive(Address * src, Protocol_Number * prot, void * data, unsigned int size);

 Buffer * alloc(Address dst, Protocol_Number prot, unsigned int size);

 int send(Buffer * buf);

 void free(Buffer * buf);

 int receive(Buffer * buf, Address * src, Address * dst, void * data, unsigned int size);

 const Address & address();

 void address(Address address);

 const Statistics & statistics();

 void attach(Observer * obs, Protocol_Number prot); // possibly inherited

 void detach(Observer * obs, Protocol_Number prot); // possibly inherited

private:

 Statistics _statistics;

 Buffer _buffer[BUFFER_SIZE];

};

// Communication Protocol

template 

class Protocol: private typename NIC::Observer

{

public:

 static const typename NIC::Protocol_Number PROTO =

 Traits::ETHERNET_PROTOCOL_NUMBER;

 typedef typename NIC::Buffer Buffer;

 typedef typename NIC::Address Physical_Address;

 typedef XXX Port;

 typedef Conditional_Data_Observer, Port> Observer;

 typedef Conditionally_Data_Observed, Port> Observed;

 class Address

 {

 public:

 enum Null;

 public:

 Address();

 Address(const Null & null);

 Address(Physical_Address paddr, Port port);

 operator bool() const { return (_paddr || _port); }

 bool operator==(Address a) { return (_paddr == a._paddr) && (_port == a._port); }

 private:

 Physical_Address _paddr;

 Port _port;

 };

 class Header;

 static const unsigned int MTU = NIC::MTU - sizeof(Header);

 typedef unsigned char Data[MTU];

 class Packet: public Header

 {

 public:

 Packet();

Header * header();

template

T * data() { return reinterpret_cast(&_data); }

 private:

Data _data;

 } __attribute__((packed));

protected:

 Protocol(NIC * nic): _nic(nic) { _nic->attach(this, PROTO); }

public:

 ~Protocol() { _nic->detach(this, PROTO); }

 static int send(Address from, Address to, const void * data, unsigned int size);

 // Buffer * buf = NIC::alloc(to.paddr, PROTO, sizeof(Header) + size)

 // NIC::send(buf)

 static int receive(Buffer * buf, Address from, void * data, unsigned int size);

 // unsigned int s = NIC::receive(buf, &from.paddr, &to.paddr, data, size)

// NIC::free(buf)

// return s;

 static void attach(Observer * obs, Address address);

 static void detach(Observer * obs, Address address);

private:

 void update(typename NIC::Observed * obs, NIC::Protocol_Number prot, Buffer * buf) {

 if(!_observed.notify(buf)) // to call receive(...);

 _nic->free(buf);

 }



private:

 NIC * _nic;



 // Channel protocols are usually singletons

 static Observed _observed;

};

// Communication End-Point (for client classes)

class Message;

template 

class Communicator: public Concurrent_Observer

{

 typedef Concurrent_Observer Observer;

public:

 typedef typename Channel::Buffer Buffer;

 typedef typename Channel::Address Address;

public:

 Communicator(Channel * channel, Address address): _channel(channel), _address(address) {

 _channel->attach(this, address);

 }

 ~Communicator_Common() { Channel::detach(this, _address); }

 bool send(const Message * message) {

 return (_channel->send(_address, Channel::Address::BROADCAST, message->data(),

 message->size()) > 0);

 }

 bool receive(Message * message) {

 Buffer * buf = Observer::updated(); // block until a notification is triggered

 Channel::Address from;

 int size = _channel->receive(buf, &from, message->data(), message->size());

 // . . .

 if(size > 0)

 return true;

 }



private:

 void update(typename Channel::Observed * obs, typename

 Channel::Observer::Observing_Condition c, Buffer * buf) {

 Observer::update(c, buf); // releases the thread waiting for data

 }

private:

 Channel * _channel;

 Address _address;

};